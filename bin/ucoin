#!/usr/bin/env node
var request   = require('request');
var program   = require('commander');
var vucoin    = require('../index');
var hdc       = require('hdc');
var fs        = require('fs');
var sha1      = require('sha1');
var async     = require('async');
var _         = require('underscore');
var merkle    = require('merkle');
var Table     = require('cli-table');
var tweetnacl = require('tweetnacl');
var moment    = require('moment');
var inquirer  = require('inquirer');
var mkdirp    = require('mkdirp');
var crypto    = require('../lib/crypto');
var base58    = require('../lib/base58');
var ask       = require('../lib/ask');
var stdinData = '';

// Consts
var NO_AUTH = false;

// Default values
program.host = "localhost";
program.port = "8081";

program
  .version('0.20.2')
  .option('--key <keyFile>', 'File of the key to submit.')
  .option('--search <search>', 'Search string')
  .option('--votefile <voteFile>', 'Vote file to send.')
  .option('--pay <issuer,number[,...]>', 'Coins to transfer.', splitCoins2)
  .option('--sender <fingerprint>', 'Sender\'s fingerprint.')
  .option('--recipient <fingerprint', 'Recipient\'s fingerprint.')
  .option('--comment <comment>', 'Comment to add to transaction.')
  .option('--transaction <txFile>', 'Transaction file to send.')
  .option('--membership <msFile>', 'Membership file to send.')
  .option('-c, --currency <name>', 'Currency name.')
  .option('-t, --timestamp <timestamp>', 'Timestamp used for GeneratedOn field in amendment.', parseInt)
  .option('-h, --host <address>', 'DNS, IPv4 or IPv6 address of the node to contact.')
  .option('-p, --port <port>', 'Port of the node to contact.')
  .option('--user <user>', 'Alias for storing data in a specific folder. Default to \'default\'')
  .option('--salt <salt>', 'Salt string')
  .option('--passwd <password>', 'Password of the key')
  .option('--store', 'Store data instead of writing to sdout')
  .option('--send', 'send data instead of writing to sdout')
  .option('-y, --yes', 'Do not ask any confirmation')

program
  .command('sec')
  .description('Get base58 secret key using --salt & --password parameters')
  .action(withKeyPair(function (pub, sec) {
    console.log(base58.encode(sec));
  }));

program
  .command('pub')
  .description('Get base58 public key using --salt & --password parameters')
  .action(withKeyPair(function (pub, sec) {
    console.log(base58.encode(pub));
  }));

program
  .command('self [uid]')
  .description('Build self-certification.')
  .action(withKeyPair(function (pub, sec, uid) {
    async.waterfall([
      function (next){
        if (uid) createSelfCert(pub, sec, uid, next);
        else readSelfCert(next);
      },
    ], handleError(function (selfCert) {
      if (program.store)
        writeInHome("self", selfCert);
      if (program.send)
        withConnection(function (node) {
          node.wot.add(base58.encode(pub), selfCert.split('\n').slice(1).join('\n'), '', function (err) {
            if (err) console.error('Error:', err);
            else console.log('Successfully sent');
          })
        })();
      if (!program.send && !program.store)
        process.stdout.write(selfCert);
    }));
  }));

function createSelfCert (pub, sec, uid, done) {
    var raw = "";
    async.waterfall([
      function (next){
        raw += base58.encode(pub) + '\n';
        raw += "UID:" + uid + '\n';
        raw += "META:TS:" + new Date().utcZero().timestamp() + '\n';
        var selfCert = raw.split('\n').slice(1).join('\n');
        crypto.sign(selfCert, sec, next);
      },
      function (sig, next){
        raw += sig + '\n';
        next(null, raw);
      },
    ], done);
}

function readSelfCert (done) {
  done(null, readInHome('self'));
}

program
  .command('join [uid] [certts]')
  .description('Send join membership request.')
  .action(withKeyPair(['currency'], function (pub, sec, uid, certts) {
    async.waterfall([
      function (next){
        if (!uid){
          next('User ID is required');
          return;
        }
        if (certts) {
          next(null, certts);
        } else {
          // Look for possible certts
          async.waterfall([
            function (next) {
              withConnection(function (node){
                node.wot.lookup(decodeURIComponent(uid), next);
              })();
            },
            function (res, next){
              var matches = [];
              var hash = {};
              res.results.forEach(function(pubres){
                matches[pubres.pubkey] = [];
                pubres.uids.forEach(function(uidres){
                  var choice = uidres.meta.timestamp + ' ' + uidres.uid;
                  hash[choice] = uidres.meta.timestamp + ' ' + uidres.uid;
                  matches.push(choice);
                });
              });
              if (matches.length == 0)
                next('No matching identity found on server');
              else {
                if (matches.length == 1)
                  next(null, matches[matches.length-1]);
                else {
                  matches = matches.concat(["None"]);
                  ask.pick("Which one to use for membership?", matches, matches[matches.length-1], function (err, said) {
                    if (said == 'None')
                      next('Aborted.');
                    else
                      next(null, hash[said]);
                  });
                }
              }
            },
          ], next);
        }
      },
      function (ts, next){
        createMembership('IN', pub, sec, uid, ts.split(' ')[0], next);
      },
    ], handleError(function (signedMS) {
      if (program.store)
        writeInHome("join", signedMS);
      if (program.send)
        withConnection(function (node) {
          node.blockchain.membership(signedMS, function (err) {
            if (err) console.error('Error:', err);
            else console.log('Successfully sent join membership.');
          })
        })();
      if (!program.send && !program.store)
        process.stdout.write(signedMS);
    }));
  }));

function createMembership (type, pub, sec, uid, certts, done) {
    var raw = "";
    async.waterfall([
      function (next){
        raw += "Version: 1" + '\n';
        raw += "Currency: " + program.currency + '\n';
        raw += "Issuer: " + base58.encode(pub) + '\n';
        raw += "Date: " + new Date().utcZero().timestamp() + '\n';
        raw += "Membership: " + type + '\n';
        if (uid) {
          raw += "UserID: " + uid + '\n';
        }
        if (certts) {
          raw += "CertTS: " + certts + '\n';
        }
        crypto.sign(raw, sec, next);
      },
      function (sig, next){
        raw += sig + '\n';
        next(null, raw);
      },
    ], done);
}

program
  .command('lookup [search]')
  .description('Show remote pubkey in ASCII armored format.')
  .action(withConnection(function (node, search) {
    async.waterfall([
      function (next){
        node.wot.lookup(search, next);
      },
      function (res, next){
        var matches = [];
        res.results.forEach(function(pubres){
          matches[pubres.pubkey] = [];
          pubres.uids.forEach(function(uidres){
            matches[pubres.pubkey].push(uidres.uid);
          });
        });
        next(null, matches);
      },
    ], handleError(function (res) {
      _(res).keys().forEach(function(pubkey){
        res[pubkey].forEach(function(uid){
          console.log(pubkey + ':' + uid);
        });
      });
    }));
  }));

program
  .command('cert [uid]')
  .description('Certify an identity matching <ui> found on remote server')
  .action(withConnection(function (node, uid) {
    async.waterfall([
      function (next){
        node.wot.lookup(uid, next);
      },
      function (res, next){
        var matches = [];
        var hash = {};
        res.results.forEach(function(pubres){
          pubres.uids.forEach(function(uidres){
            var day = moment.unix(uidres.meta.timestamp);
            var id = [uidres.uid, day.format('lll'), uidres.self.substring(0, 8)].join(' ');
            hash[id] = { pub: pubres.pubkey, uid: uidres.uid, time: uidres.meta.timestamp, sig: uidres.self };
            matches.push(id);
          });
        });
        if (matches.length == 0)
          next('No matching identity found on server');
        else {
          if (matches.length == 1)
            next(null, hash[matches[matches.length-1]]);
          else {
            matches = matches.concat(["None"]);
            ask.pick("Which one to sign?", matches, matches[matches.length-1], function (err, said) {
              if (said == 'None')
                next('Aborted.');
              else
                next(null, hash[said]);
            });
          }
        }
      },
      function (sCert, next){
        var now = moment().unix();
        var toBeSigned = ['UID:' + sCert.uid, 'META:TS:' + sCert.time, sCert.sig, 'META:TS:' + now, ''].join('\n');
        if (program.yes)
          next(null, toBeSigned, now, sCert.pub);
        else {
          console.log('-----------------');
          console.log(toBeSigned);
          console.log('-----------------');
          ask.choose('You are about to sign this identity, continue?', false,
            async.apply(next, null, toBeSigned, now, sCert.pub),
            async.apply(next, 'Aborted.'));
        }
      },
      function (certification, when, sPub, next){
        sign(certification, function (err, sig, pub){
          next(err, certification + sig, pub, when, sPub);
        });
      },
      function (oCert, pub, when, sPub, next){
        var lines = oCert.split('\n');
        var inline = [
          base58.encode(pub),
          sPub,
          when,
          lines.slice(lines.length-1)
        ].join(':') + '\n';
        next(null, inline, sPub, lines.slice(0, 3).join('\n'));
      },
    ], handleError(function (inline, sPub, selfCert) {
      if (program.send)
        node.wot.add(sPub, selfCert, inline, function (err) {
          if (err) console.error('Error:', err);
          else console.log('Successfully sent');
        })
      if (!program.send && !program.store)
        console.log(inline);
    }));
  }));

function sign (msg, done) {
  async.waterfall([
    function (next){
      if (program.passwd) next(null, program.passwd);
      else ask.password(next);
    },
    function (passwd, next){
      crypto.getKeyPair(passwd, program.salt, next);
    },
    function (pair, next){
      crypto.sign(msg, pair.secretKey, function (err, sig) {
        next(err, sig, pair.publicKey);
      });
    },
  ], done);
}

// program
//   .command('currency')
//   .description('Give currency name for a given host and port.')
//   .action(connect(function (node) {
//     node.network.peering.get(proxy(function (json) {
//       console.log(json.currency);
//     }));
//     return;
//   }));

program
  .command('pub-wallet')
  .description('Publish Wallet.')
  .action(function(){
    // Read STDIN first
    process.stdin.setEncoding('utf8');
    process.stdin.on('data', function(chunk) {
      stdinData += chunk;
    });
    process.stdin.on('end', function() {
      connect(function (node) {
        node.network.wallet.post(stdinData, proxy(function (json) {
          console.log('Posted Wallet.');
        }));
      })();
    });
    return;
  });

program
  .command('pks-add')
  .description('Add signed public keys')
  .action(connect(function (node) {
    if(!program.key){
      console.error("Requires --key parameter");
      return;
    }
    var key = fs.readFileSync(program.key, 'utf8');
    if(key){
      node.pks.add(key, proxy(function (res) {
        var name = res.name || '';
        var comment = res.comment ? ' (' + res.comment + ')' : '';
        var email = res.email ? ' <' + res.email + '>' : '';
        console.log("Posted key '" + res.fingerprint + "' of " + name + comment + email);
      }));
    }
    else{
      console.error("Missing key in given file.");
    }
    return;
  }));

program
  .command('pks-lookup')
  .description('Search for public keys.')
  .action(connect(function (node) {
    if(!program.search){
      console.error("Requires --search parameter");
      return;
    }
    node.pks.lookup(program.search, proxy(function (res) {
      var keys = res.keys;
      console.log("Lookup '" + program.search + "' keys:");
      for (var i = 0; i < keys.length; i++) {
        console.log(keys[i].key.fingerprint);
      };
    }));
    return;
  }));

program
  .command('peer')
  .description('Show remote peering informations.')
  .action(connect(function (node) {
    node.network.peering.get(proxy(function (res) {
      console.log("Currency: %s", res.currency);
      console.log("Public key: %s", res.fingerprint);
      res.endpoints.forEach(function(endpoint, index){
        console.log('Endpoint %s: %s', index, endpoint);
      });
    }));
    return;
  }));

program
  .command('am-current')
  .description('View current top amendment of the contract.')
  .action(connect(function (node) {
    node.hdc.amendments.current(proxy(function (res) {
      var amendment = new hdc.Amendment(res.raw);
      console.log(amendment.getRaw());
    }));
    return;
  }));

program
  .command('am-initial [currency] [community]')
  .description('View initially proposed AM0 amendment.')
  .action(connect(function (currency, community, node) {
    async.waterfall([
      function(next){
        node.hdc.amendments.current(function (err, res) {
          if (err) {
            next(null, -1);
            return;
          } else {
            var amendment = new hdc.Amendment(res.raw);
            next(null, amendment.number);
          }
        });
      },
      function (nextNumber, next){
        node.registry.parameters(next);
      },
    ], function (err, params) {
      if (err) {
        console.error(err);
        process.exit(1);
        return;
      }
      var members = community.split(';')[0].split(':').sort();
      var voters = community.split(';')[1].split(':').sort();
      var membersTree = merkle(members, 'sha1').process();
      var votersTree = merkle(voters, 'sha1').process();
      var raw = "Version: 1\r\n" +
      "Currency: " + currency  + "\r\n" +
      "Number: 0\r\n" +
      "GeneratedOn: " + params.AMStart + "\r\n" +
      "NextRequiredVotes: " + Math.ceil(params.Consensus*voters.length) + "\r\n" +
      "MembersRoot: " +  membersTree.root() + "\r\n" +
      "MembersCount: " +  members.length + "\r\n" +
      "MembersChanges:\r\n";
      members.forEach(function(fpr){
        raw += "+" + fpr + "\r\n";
      });
      raw += "" +
      "VotersRoot: " +  votersTree.root() + "\r\n" +
      "VotersCount: " +  voters.length + "\r\n" +
      "VotersChanges:\r\n";
      voters.forEach(function(fpr){
        raw += "+" + fpr + "\r\n";
      });
      console.log(raw);
    });
    return;
  }));

program
  .command('am-contract')
  .description('View all amendments of the contract.')
  .action(connect(function (node) {
    function getAmendment (number, hash) {
      node.hdc.amendments.view.self(number, hash, proxy(function (res) {
        var amendment = new hdc.Amendment(res.raw);
        console.log(res.raw + "------------------------------------");
        if(amendment.previousHash){
          getAmendment(amendment.number - 1, amendment.previousHash);
        }
      }));
    }
    console.log("-----------------------------------");
    console.log("-             CONTRACT            -");
    console.log("-----------------------------------");
    node.hdc.amendments.current(proxy(function (res) {
      var amendment = new hdc.Amendment(res.raw);
      console.log(amendment.getRaw() + "------------------------------------");
      if(amendment.previousHash){
        getAmendment(amendment.number - 1, amendment.previousHash);
      }
    }));
    return;
  }));

program
  .command('members [number]')
  .description('View members present for at given amendment number. Defaults to current amendment number.')
  .action(connect(function (number, node) {
    async.waterfall([
      function (next){
        if (number >= 0) {
          node.hdc.amendments.promoted(number, next);
        } else {
          node.hdc.amendments.current(next);
        }
      },
      function (json, next){
        var amendment = new hdc.Amendment(json.raw);
        node.hdc.amendments.view.members(amendment.number, amendment.hash, { leaves: true }, next);
      },
      function (json, next){
        json.leaves.forEach(function(leaf){
          console.log(leaf);
        });
        next();
      },
    ], function (err) {
      if (err) {
        console.log(err);
        process.exit(1);
      }
    });
    return;
  }));

program
  .command('tx-show-last [count]')
  .description('Show last [count] transactions (default to one).')
  .action(connect(function (count, node) {
    count = count || 1;
    node.hdc.transactions.lasts(count, proxy(function (res) {
      res.transactions.forEach(function (tx) {
        var hdxTX = new hdc.Transaction();
        _(hdxTX).keys().forEach(function (key) {
          if(tx[key]){
            hdxTX[key] = tx[key];
          }
        });
        hdxTX.coins = [];
        tx.coins.forEach(function (coin) {
          hdxTX.coins.push(coin.id + ', ' + coin.transaction_id);
        })
        console.log(hdxTX.getRaw());
      })
    }));
    return;
  }));

program
  .command('tx-sender-show-last [count]')
  .description('Show last [count] transactions of sender (default to one).')
  .action(connect(function (count, node) {
    count = count || 1;
    if(!program.sender){
      console.error("Requires --sender parameter");
      return;
    }
    node.hdc.transactions.sender.lasts(program.sender, count, proxy(function (res) {
      res.transactions.forEach(function (tx) {
        var hdxTX = new hdc.Transaction();
        _(hdxTX).keys().forEach(function (key) {
          if(tx[key]){
            hdxTX[key] = tx[key];
          }
        });
        hdxTX.coins = [];
        tx.coins.forEach(function (coin) {
          hdxTX.coins.push(coin.id + ', ' + coin.transaction_id);
        })
        console.log(hdxTX.getRaw());
      })
    }));
    return;
  }));

program
  .command('coins-list [owner]')
  .description('Show coins of given owner.')
  .action(connect(function (owner, node) {
    if(!owner){
      console.error('owner is required');
      return;
    }
    var coins = {};
    var amendments = {};
    node.hdc.coins.list(owner, proxy(function (res) {
      var sum = 0;
      async.forEachSeries(res.coins, function(coinId, callback){
        var c = coinId.coin();
        getAmendment(amendments, c, node, function (err, amount) {
          if (!err) {
            // Coins per value
            coins[amount] = coins[amount] || [];
            coins[amount].push(c);
            sum += amount;
          }
          callback(err);
        });
      }, function(err){
        if (err) {
          console.error(err);
          return;
        }
        console.log("Credit: " + sum);
        console.log("-------------------");
        var table = new Table({
          head: ['Value', 'Quantity', ''],
          colWidths: [Math.min(6, (""+sum).length + 5), 41, 10],
          chars: {'top': '' , 'top-mid': '' , 'top-left': '' , 'top-right': ''
               , 'bottom': '' , 'bottom-mid': '' , 'bottom-left': '' , 'bottom-right': ''
               , 'left': '' , 'left-mid': '' , 'mid': '' , 'mid-mid': ''
               , 'right': '' , 'right-mid': '' , 'middle': '' },
          style: { 'padding-left': 0, 'padding-right': 0, compact : true }
        });

        var keys = _(coins).keys();
        keys.sort().reverse();
        keys.forEach(function (amount) {
          table.push([amount, coins[amount].length]);
        });
        console.log(table.toString());
      });
    }));
  }));

program
  .command('coins-get [owner]')
  .description('Get a random set of coins with given values, owned by [owner].')
  .action(connect(function (owner, node) {
    if(!owner){
      console.error('owner is required');
      return;
    }
    if(!program.pay){
      console.error("Requires --pay parameter");
      return;
    }
    var coins = {};
    var amendments = {};
    node.hdc.coins.list(owner, proxy(function (res) {
      async.forEachSeries(res.coins, function (id, callback) {
        var tx = new hdc.Transaction();
        tx.coins = [];
        tx.coins.push(id);
        var c = tx.getCoins()[0];
        getAmendment(amendments, c, node, function (err, amount) {
          if (!err) {
            // Coins per value
            coins[amount] = coins[amount] || [];
            coins[amount].push(c);
          }
          callback(err);
        });
      }, function (err) {

        if(err){
          console.error(err);
          return;
        }

        var get = {};
        var err = null;
        program.pay.forEach(function (coin) {
          var amount = parseInt(coin.value);
          if(coins[amount] && coins[amount].length > 0){
            var c = coins[amount][0];
            get[c.issuer] = get[c.issuer] || [];
            get[c.issuer].push(c);
            coins[amount].splice(0,1); // No more available
          }
          else{
            err = 'You do not have enough coins of value (' + amount + ')';
            return;
          }
        });

        if(err){
          console.error(err);
          return;
        }

        var keys = _(get).keys();
        var str = '';
        keys.sort().reverse();
        keys.forEach(function (key) {
          str += str == '' ? '' : ',';
          str += key;
          get[key].forEach(function (coin) {
            str += ':' + [coin.amNumber, coin.coinNumber].join('-');
          });
        });
        console.log(str);
      });
    }));
    return;
  }));

program
  .command('transfer')
  .description('Send transfer transaction.')
  .action(connect(function (node) {
    if(!program.transaction){
      console.error("Requires --transaction parameter");
      return;
    }
    var tx = fs.readFileSync(program.transaction, 'utf8');
    node.hdc.transactions.process(tx, proxy(function (res) {
      console.log("Posted transfer transaction");
    }));
    return;
  }));

program
  .command('vote')
  .description('Send vote request.')
  .action(connect(function (node) {
    if(!program.votefile){
      console.error("Requires --votefile parameter");
      return;
    }
    var vote = fs.readFileSync(program.votefile, 'utf8');
    node.hdc.amendments.votes.post(vote, proxy(function (res) {
      console.log("Posted vote for Amendment #" + res.amendment.number);
    }));
    return;
  }));

program
  .command('utc-timestamp')
  .description('Get current timestamp for UTC+0 timezone.')
  .action(function () {
    var now = new Date();
    console.log(Math.floor(now.getTime()/1000) + now.getTimezoneOffset()*60);
  });

program
  .command('update-membership')
  .description('Send membership request.')
  .action(connect(NO_AUTH, function (node) {
    if(!program.membership){
      console.error("Requires --membership parameter");
      return;
    }
    var vote = fs.readFileSync(program.membership, 'utf8');
    node.keychain.membership(vote, proxy(function (res) {
      console.log("Posted membership " + res.membership.membership + " for key " + res.membership.issuer);
    }));
    return;
  }));

program
  .command('forge-transfer')
  .description('Forge HDC issuance transaction.')
  .action(connect(function (node) {
    var tx = new hdc.Transaction();
    async.waterfall([
      function (next){
        // Options control
        if(!program.pay){
          next('You must give at least one coin with --pay option');
          return;
        }
        if(!program.sender){
          next('You must give sender\'s fingerprint with --sender option');
          return;
        }
        if(!program.recipient){
          next('You must give recipient\'s fingerprint with --recipient option');
          return;
        }
        next();
      },
      function (next){
        node.network.peering.get(next);
      },
      function (peering, next){
        tx.version = "1";
        tx.currency = peering.currency;
        tx.sender = program.sender;
        tx.recipient = program.recipient;
        tx.comment = program.comment ? program.comment : '';
        tx.coins = [];
        // Find last transaction
        node.hdc.transactions.sender.lasts(tx.sender, 1, function (err, res) {
          var txs = res.transactions;
          if (!err && txs && txs[0]) {
            var lastTx = txs[0];
            var newTx = new hdc.Transaction();
            _(newTx).extend(lastTx);
            newTx.coins.sort();
            tx.number = parseInt(lastTx.number, 10) + 1;
            tx.previousHash = sha1(newTx.getRaw().unix2dos() + lastTx.signature).toUpperCase();
          } else {
            tx.number = 0;
          }
          next();
        });
      },
      function (next) {
        async.forEach(program.pay, function(coin, callback){
          node.hdc.coins.owner(coin.issuer, coin.amNumber, coin.coinNumber, function (err, json) {
            if (!err) {
              var line = json.coinid;
              if (json.transaction) {
                console.log(json.transaction);
                line += ':' + json.transaction;
              }
              tx.coins.push(line);
            }
            callback(err);
          });
        }, function (err) {
          tx.coins.sort();
          next(err);
        });
      }
    ], function (err, result) {
      if(err){
        console.error(err);
        process.exit(1);
        return;
      }
      console.log(tx.getRaw());
    });
    return;
  }));

program
  .command('forge-amendment')
  .description('Forge HDC amendment according to uCoin server received data.')
  .action(connect(function (node) {
    var forgedAM = new hdc.Amendment();
    var mapMss = {};
    var mapSig = {};
    var previousVoters = [];
    var membersChanges = toChanges(program.mchanges);
    var votersChanges = toChanges(program.vchanges);
    var membersToAdd = _(membersChanges)
      .filter(filterPlus)
      .map(withoutPlusOrMinus);
    var membersToRemove = _(membersChanges)
      .filter(filterMinus)
      .map(withoutPlusOrMinus);
    var votersToAdd = _(votersChanges)
      .filter(filterPlus)
      .map(withoutPlusOrMinus);
    var votersToRemove = _(votersChanges)
      .filter(filterMinus)
      .map(withoutPlusOrMinus);
    // If any members to add is also to remove
    membersToAdd = _(membersToAdd).difference(membersToRemove);
    async.waterfall([
      function (next){
        // Build an amendment following current amendment of the node
        node.hdc.amendments.current(function (err, am) {
          if(!am){
            // If no amendment, then default
            async.waterfall([
              function (cb){
                node.network.peering.get(cb);
              }
            ], function (err, result) {
              next(err, {
                currency: result.currency,
                number: -1,
                votersCount: 0,
                membersCount: 0
              });
            });
            return;
          }
          next(err, am);
        });
      },
      function (am, next){
        forgedAM.version = 1;
        forgedAM.currency = am.currency;
        forgedAM.number = am.number + 1;
        forgedAM.dividend = program.dividend; // If no dividend, field is null hence not taken
        forgedAM.coinMinPower = program.mincoin; // Same as dividend
        forgedAM.nextVotes = program.votes;
        forgedAM.generated = program.timestamp || (new Date().getTime()/1000).toFixed(0);
        if(am.raw){
          forgedAM.previousHash = sha1(am.raw).toUpperCase();
        }
        next(null);
      },
      function (next) {
        // Getting previous amendment members tree
        if (forgedAM.number == 0) {
            next(null, { leaves: [] });
        } else {
          node.hdc.amendments.view.members(forgedAM.number - 1, forgedAM.previousHash, {
            leaves: true
          }, next);
        }
      },
      function (json, next){
        // Computes new members tree
        var members = [];
        var previousMembers = [];
        var reallyAddedMembers = [];
        var reallyRemovedMembers = [];
        // Add previous members
        // console.log(json);
        json.leaves.forEach(function(fingerprint){
          members.push(fingerprint);
          previousMembers.push(fingerprint);
        });
        // Add new members
        membersToAdd.forEach(function(fingerprint){
          members.push(fingerprint);
        });
        members.sort();
        var isSorted = true;
        // Remove eventual duplicates
        members = _(members).uniq(isSorted);
        // Remove members to remove
        members = _(members).difference(membersToRemove);
        reallyAddedMembers = _(members).difference(previousMembers);
        reallyRemovedMembers = _(membersToRemove).difference(members);
        reallyRemovedMembers = _(reallyRemovedMembers).intersection(previousMembers);
        var membersMerkle = merkle(members, 'sha1').process();
        // Writes members changes
        forgedAM.membersChanges = [];
        reallyAddedMembers.forEach(function(fpr){
          forgedAM.membersChanges.push('+' + fpr);
        });
        reallyRemovedMembers.forEach(function(fpr){
          forgedAM.membersChanges.push('-' + fpr);
        });
        forgedAM.membersChanges.sort(); // Important to have a valid amendment
        forgedAM.membersCount = membersMerkle.leaves.length;
        forgedAM.membersRoot = membersMerkle.root();
        next(null);
      },
      function (next) {
        // Getting previous amendment voters tree
        if (forgedAM.number == 0) {
            next(null, { leaves: [] });
        } else {
          node.hdc.amendments.view.voters(forgedAM.number - 1, forgedAM.previousHash, {
            leaves: true
          }, next);
        }
      },
      function (json, next){
        // Computes new voters tree
        var voters = [];
        var previousVoters = [];
        var reallyAddedVoters = [];
        var reallyRemovedVoters = [];
        // Add previous voters
        json.leaves.forEach(function(fingerprint){
          voters.push(fingerprint);
          previousVoters.push(fingerprint);
        });
        // Add new voters
        votersToAdd.forEach(function(fingerprint){
          voters.push(fingerprint);
        });
        voters.sort();
        var isSorted = true;
        // Remove eventual duplicates
        voters = _(voters).uniq(isSorted);
        // Remove voters to remove
        voters = _(voters).difference(votersToRemove);
        reallyAddedVoters = _(voters).difference(previousVoters);
        reallyRemovedVoters = _(votersToRemove).difference(voters);
        var votersMerkle = merkle(voters, 'sha1').process();
        // Writes voters changes
        forgedAM.votersChanges = [];
        reallyAddedVoters.forEach(function(fpr){
          forgedAM.votersChanges.push('+' + fpr);
        });
        reallyRemovedVoters.forEach(function(fpr){
          forgedAM.votersChanges.push('-' + fpr);
        });
        forgedAM.votersChanges.sort(); // Important to have a valid amendment
        forgedAM.votersCount = votersMerkle.leaves.length;
        forgedAM.votersRoot = votersMerkle.root();
        next(null);
      },
    ], function (err, result) {
      console.log(forgedAM.getRaw());
    });
    return;
  }));

program
  .command('index')
  .description('List received votes count for each amendment.')
  .action(connect(function (node) {
    node.hdc.amendments.votes.get(proxy(function (res) {
      _(res.amendments).each(function (ams, number) {
        _(ams).each(function (count, amHash) {
          console.log(number + "-" + amHash + ":" + count);
        });
      });
    }));
    return;
  }));

program.parse(process.argv);

function connect(auth, callback) {
  if (arguments.length == 1) {
    callback = auth;
    auth = true;
  }
  return function () {
    var cbArgs = arguments;
    vucoin(program.host, program.port, function (err, node) {
      if(err){
        console.error(err);
        return;
      }
      cbArgs.length > 0 && cbArgs.length--;
      cbArgs[cbArgs.length++] = node;
      callback.apply(this, cbArgs);
    });
  };
}

function proxy(callback){
  return function (err, res) {
    if(err){
      if(err.code)
        console.error("Error: " + err.code);
      else
        console.error("Error: " + err);
      process.exit(1);
      return;
    }
    else callback(res);
  }
}

function splitCoins (arg) {
  var strings = arg.split(',');
  var values = [];
  for(var i = 0; i < strings.length - 1; i = i + 2){
    values.push({
      base: parseInt(strings[i], 10),
      power: parseInt(strings[i+1], 10)
    });
  }
  return values;
}

function splitCoins2 (arg) {
  var strings = arg.split(',');
  var values = [];
  for(var i = 0; i < strings.length; i++){
    var group = strings[i].split(':');
    var start = strings[0].match(/^[A-Z\d]{40}/) ? 1 : 0;
    for(var j = start; j < group.length; j++){
      if(group[j] && group[j] != ''){
        var subIds = group[j].match(/^(\d+)(-(\d+))?$/);
        values.push({
          issuer: start == 1 ? group[0] : '',
          amNumber:  subIds[3] ? parseInt(subIds[1]) : '',
          coinNumber: subIds[3] ? parseInt(subIds[3]) : '',
          value: !subIds[3] ? parseInt(subIds[1]) : ''
        });
      }
    }
  }
  return values;
}

function getLastIssuedCoin(tx) {
  if (tx.type == 'ISSUANCE') {
    // Get last coin of the list
    var coins = tx.getCoins();
    return coins[coins.length - 1];
  } else if (tx.type == 'CHANGE') {
    // Get last coin of the list with no TRANSACTION_ID
    var coins = tx.getCoins();
    var lastCoin = null;
    var i = 0;
    while (coins[i] && !coins[i].transaction) {
      lastCoin = coins[i];
      i++;
    }
    return lastCoin;
  } else {
    // No issued coin exists
    return null;
  }
}

function toChanges (str) {
  var changesStr = (str || "")
    .replace(/"/g, '')
    .replace(/\+/g, ';+')
    .replace(/-/g, ';-');
  var changes = [];
  changesStr.split(';').forEach(function(item){
    if (item != "") {
      changes.push(item);
    }
  });
  return changes;
}

function filterPlus (item){
  return item.match(/\+/);
}

function filterMinus (item){
  return item.match(/-/);
}

function withoutPlusOrMinus(item){
  return item.substr(1);
}

function getAmendment (amendments, c, node, done) {
  async.waterfall([
    function (next){
      if (amendments[c.amNumber]) {
        next(null, amendments[c.amNumber]);
      } else {
        node.hdc.amendments.promoted(c.amNumber, proxy(function (res) {
          amendments[c.amNumber] = res;
          next(null, amendments[c.amNumber]);
        }));
      }
    },
    function (am, next){
      done(null, coinValue(c.coinNumber, am));
    },
  ], done);
}

function coinValue (coinNumber, am) {
  var power = am.coinBase;
  var decr = coinNumber;
  am.coinList.forEach(function(quantity){
    if (decr <= quantity) {
      return;
    }
    decr -= quantity;
    power++;
  });
  return Math.pow(2, power);
}

function handleError (success) {
  return function () {
    if (arguments[0])
      console.error(arguments[0]);
    else {
      var args = Array.prototype.slice.call(arguments);
      success.apply(success, args.slice(1));
    }
  };
}

function withKeyPair (parameters, done) {
  if (arguments.length == 1) {
    done = parameters;
    parameters = [];
  }
  return withParams(['salt', 'passwd'].concat(parameters), function () {
    var args = Array.prototype.slice.call(arguments);
    crypto.getKeyPair(program.passwd, program.salt, function (err, pair) {
      done.apply(done, [pair.publicKey, pair.secretKey].concat(args));
    });
  });
}

function withConnection (parameters, done) {
  if (arguments.length == 1) {
    done = parameters;
    parameters = [];
  }
  return withParams(['host', 'port'], function () {
    var args = Array.prototype.slice.call(arguments);
    vucoin(program.host, program.port, function (err, node) {
      if (err) {
        console.error(err);
        process.exit(1);
      }
      done.apply(done, [node].concat(args));
    });
  });
}

function withParams (parameters, done) {
  return function () {
    var err = null;
    parameters.forEach(function(p){
      if(!err && !program[p]){
        err = "Requires --" + p + " parameter";
      }
    });
    if (err) {
      console.error(err);
      process.exit(1);
    }
    done.apply(done, arguments);
  };
}

function writeInHome (fileName, content) {
  var homePath = process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE;
  var ucoinPath = homePath + '/.ucoin/' + (program.user ? program.user : 'defaut');
  mkdirp.sync(ucoinPath, '0770');
  fs.writeFileSync(ucoinPath + '/' + fileName, content, 'utf8');
}

function readInHome (fileName) {
  var homePath = process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE;
  var ucoinPath = homePath + '/.ucoin/' + (program.user ? program.user : 'defaut');
  mkdirp.sync(ucoinPath, '0660');
  var filePath = ucoinPath + '/' + fileName;
  return fs.existsSync(filePath) ? fs.readFileSync(filePath, 'utf8') : '';
}

String.prototype.trim = function(){
  return this.replace(/^\s+|\s+$/g, '');
};

String.prototype.unix2dos = function(){
  return this.dos2unix().replace(/\n/g, '\r\n');
};

String.prototype.dos2unix = function(){
  return this.replace(/\r\n/g, '\n');
};

String.prototype.coin = function(){
  var matches = this.match(/([A-Z\d]{40})-(\d+)-(\d+)(:([A-Z\d]{40})-(\d+))?/);
  if(matches && matches.length == 7){
    return {
      issuer: matches[1],
      amNumber: parseInt(matches[2], 10),
      coinNumber: parseInt(matches[3], 10),
      transaction: matches[4] && {
        sender: matches[5],
        number: matches[6]
      }
    };
  } else {
    return null;
  }
};

Date.prototype.utc = function(){
  return new Date();
};

Date.prototype.utcZero = function(){
  return new Date(this.getTime() + this.getTimezoneOffset()*60*1000);
};

Date.prototype.timestamp = function(){
  return Math.floor(this.getTime() / 1000);
};
