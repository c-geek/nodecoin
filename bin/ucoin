#!/usr/bin/env node
var request = require('request');
var program = require('commander');
var vucoin  = require('../index');
var hdc     = require('hdc');
var fs      = require('fs');
var sha1    = require('sha1');
var async   = require('async');
var _       = require('underscore');
var merkle  = require('merkle');
var Table   = require('cli-table');
var stdinData = '';

// Default values
program.host = "localhost";
program.port = "8081";

program
  .version('0.6.1')
  .option('--key <keyFile>', 'File of the key to submit.')
  .option('--search <search>', 'Search string')
  .option('--votefile <voteFile>', 'Vote file to send.')
  .option('--coins <base,power[,...]>', 'Coins to create.', splitCoins)
  .option('--pay <issuer,number[,...]>', 'Coins to transfer.', splitCoins2)
  .option('--sender <fingerprint>', 'Sender\'s fingerprint.')
  .option('--recipient <fingerprint', 'Recipient\'s fingerprint.')
  .option('--comment <comment>', 'Comment to add to transaction.')
  .option('--transaction <txFile>', 'Transaction file to send.')
  .option('-d, --dividend <amount>', 'Universal Dividend amount.', parseInt)
  .option('-m, --mincoin <pow10>', 'New coins minimal 10 power.', parseInt)
  .option('-n, --votes <number>', 'Number of votes required for amendment.', parseInt)
  .option('-s, --signature <sigFile>', 'File of a signature to append.')
  .option('-t, --timestamp <timestamp>', 'Timestamp used for GeneratedOn field in amendment.', parseInt)
  .option('--mchanges <+-fingerprints>', 'Members changes: chain of fingerprints, preceeded by a + or - char.')
  .option('--vchanges <+-fingerprints>', 'Voters changes: chain of fingerprints, preceeded by a + or - char.')
  .option('-h, --host <address>', 'DNS, IPv4 or IPv6 address of the node to contact.')
  .option('-p, --port <port>', 'Port of the node to contact.')

program
  .command('pubkey')
  .description('Show remote pubkey in ASCII armored format.')
  .action(connect(function (node) {
    node.ucg.pubkey(proxy(function (res) {
      console.log(res);
    }));
    return;
  }));

program
  .command('currency')
  .description('Give currency name for a given host and port.')
  .action(connect(function (node) {
    node.ucg.peering.peer(proxy(function (json) {
      console.log(json.currency);
    }));
    return;
  }));

program
  .command('pub-tht')
  .description('Publish THT entry.')
  .action(function(){
    // Read STDIN first
    process.stdin.setEncoding('utf8');
    process.stdin.on('data', function(chunk) {
      stdinData += chunk;
    });
    process.stdin.on('end', function() {
      connect(function (node) {
        node.ucg.tht.post(stdinData, proxy(function (json) {
          console.log('Posted THT entry.');
        }));
      })();
    });
    return;
  });

program
  .command('pks-add')
  .description('Add signed public keys')
  .action(connect(function (node) {
    if(!program.key){
      console.error("Requires --key parameter");
      return;
    }
    var key = fs.readFileSync(program.key, 'utf8');
    var sign = null;
    if(~key.indexOf('-----BEGIN PGP SIGNATURE-----')){
      sign = key.substr(key.indexOf('-----BEGIN PGP SIGNATURE-----'));
      key = key.substr(0, key.indexOf('-----BEGIN PGP SIGNATURE-----'));
    }
    if(~key.indexOf('-----BEGIN PGP MESSAGE-----')){
      sign = key.substr(key.indexOf('-----BEGIN PGP MESSAGE-----'));
      key = key.substr(0, key.indexOf('-----BEGIN PGP MESSAGE-----'));
    }
    else if(program.signature){
      signature = fs.readFileSync(signature, 'utf8');
    }
    if(key && sign){
      node.pks.add(key, sign, proxy(function (res) {
        var name = res.key.name || '';
        var comment = res.key.comment ? ' (' + res.key.comment + ')' : '';
        var email = res.key.email ? ' <' + res.key.email + '>' : '';
        console.log("Posted key '" + res.key.fingerprint + "' of " + name + comment + email);
      }));
    }
    else{
      if(!key){
        console.error("Missing key in given file.");
      }
      if(!sign){
        console.error("Missing signature in given file.");
      }
    }
    return;
  }));

program
  .command('pks-lookup')
  .description('Search for public keys.')
  .action(connect(function (node) {
    if(!program.search){
      console.error("Requires --search parameter");
      return;
    }
    node.pks.lookup(program.search, proxy(function (res) {
      var keys = res.keys;
      console.log("Lookup '" + program.search + "' keys:");
      for (var i = 0; i < keys.length; i++) {
        console.log(keys[i].key.fingerprint);
      };
    }));
    return;
  }));

program
  .command('peer')
  .description('Show remote peering informations.')
  .action(connect(function (node) {
    node.ucg.peering.get(proxy(function (res) {
      console.log("Currency: %s", res.currency);
      console.log("Public key FPR: %s", res.key);
      console.log("Contract: %s", res.contract.currentNumber === '' ? 'none' : res.contract.currentNumber + '-' + res.contract.hash);
      console.log("Public keys: %s", res.merkles["pks/all"].leavesCount);
      res.remote.host != '' && console.log("Remote host: %s", res.remote.host);
      res.remote.ipv4 != '' && console.log("Remote ipv4: %s", res.remote.ipv4);
      res.remote.ipv6 != '' && console.log("Remote ipv6: %s", res.remote.ipv6);
      res.remote.port != null && console.log("Remote port: %s", res.remote.port);
    }));
    return;
  }));

program
  .command('am-current')
  .description('View current top amendment of the contract.')
  .action(connect(function (node) {
    node.hdc.amendments.current(proxy(function (res) {
      var amendment = new hdc.Amendment(res.raw);
      console.log(amendment.getRaw());
    }));
    return;
  }));

program
  .command('am-contract')
  .description('View all amendments of the contract.')
  .action(connect(function (node) {
    function getAmendment (number, hash) {
      node.hdc.amendments.view.self(number, hash, proxy(function (res) {
        var amendment = new hdc.Amendment(res.raw);
        console.log(res.raw + "------------------------------------");
        if(amendment.previousHash){
          getAmendment(amendment.number - 1, amendment.previousHash);
        }
      }));
    }
    console.log("-----------------------------------");
    console.log("-             CONTRACT            -");
    console.log("-----------------------------------");
    node.hdc.amendments.current(proxy(function (res) {
      var amendment = new hdc.Amendment(res.raw);
      console.log(amendment.getRaw() + "------------------------------------");
      if(amendment.previousHash){
        getAmendment(amendment.number - 1, amendment.previousHash);
      }
    }));
    return;
  }));

program
  .command('tx-show-last [count]')
  .description('Show last [count] transactions (default to one).')
  .action(connect(function (count, node) {
    count = count || 1;
    node.hdc.transactions.lasts(count, proxy(function (res) {
      res.transactions.forEach(function (tx) {
        var hdxTX = new hdc.Transaction();
        _(hdxTX).keys().forEach(function (key) {
          if(tx[key]){
            hdxTX[key] = tx[key];
          }
        });
        hdxTX.coins = [];
        tx.coins.forEach(function (coin) {
          hdxTX.coins.push(coin.id + ', ' + coin.transaction_id);
        })
        console.log(hdxTX.getRaw());
      })
    }));
    return;
  }));

program
  .command('tx-sender-show-last [count]')
  .description('Show last [count] transactions of sender (default to one).')
  .action(connect(function (count, node) {
    count = count || 1;
    if(!program.sender){
      console.error("Requires --sender parameter");
      return;
    }
    node.hdc.transactions.sender.lasts(program.sender, count, proxy(function (res) {
      res.transactions.forEach(function (tx) {
        var hdxTX = new hdc.Transaction();
        _(hdxTX).keys().forEach(function (key) {
          if(tx[key]){
            hdxTX[key] = tx[key];
          }
        });
        hdxTX.coins = [];
        tx.coins.forEach(function (coin) {
          hdxTX.coins.push(coin.id + ', ' + coin.transaction_id);
        })
        console.log(hdxTX.getRaw());
      })
    }));
    return;
  }));

program
  .command('coins-list [owner] [upperlimit]')
  .description('Show coins of given owner, whose value is under [upperlimit].')
  .action(connect(function (owner, upperlimit, node) {
    if(!owner){
      console.error('owner is required');
      return;
    }
    upperlimit = upperlimit ? parseInt(upperlimit) : null;
    var coins = {};
    node.hdc.coins.list(owner, proxy(function (res) {
      var sum = 0;
      res.coins.forEach(function (issued) {
        issued.ids.forEach(function (id) {
          var tx = new hdc.Transaction();
          tx.coins = [];
          tx.coins.push(issued.issuer + '-' + id);
          var c = tx.getCoins()[0];
          var amount = c.base * Math.pow(10, c.power);
          if(!upperlimit || upperlimit >= amount){
            coins[amount] = coins[amount] || [];
            coins[amount].push(c);
            sum += amount;
          }
        });
      });
      console.log("Credit: " + sum);
      console.log("-------------------");
      var table = new Table({
        head: ['Value', 'Issuer', '#'],
        colWidths: [Math.min(6, (""+sum).length + 5), 41, 10],
        chars: { 'top': '' , 'top-mid': '' , 'top-left': '' , 'top-right': ''
             , 'bottom': '' , 'bottom-mid': '' , 'bottom-left': '' , 'bottom-right': ''
             , 'left': '' , 'left-mid': '' , 'mid': '' , 'mid-mid': ''
             , 'right': '' , 'right-mid': '' , 'middle': '' },
        style: { 'padding-left': 0, 'padding-right': 0, compact : true }
      });

      var keys = _(coins).keys();
      keys.sort().reverse();
      keys.forEach(function (key) {
        coins[key].forEach(function (coin) {
          table.push([key, coin.issuer, coin.number]);
        });
      });
      console.log(table.toString());
    }));
    return;
  }));

program
  .command('coins-get [owner]')
  .description('Get a random set of coins with given values, owned by [owner].')
  .action(connect(function (owner, node) {
    if(!owner){
      console.error('owner is required');
      return;
    }
    if(!program.pay){
      console.error("Requires --pay parameter");
      return;
    }
    var coins = {};
    node.hdc.coins.list(owner, proxy(function (res) {
      res.coins.forEach(function (issued) {
        issued.ids.forEach(function (id) {
          var tx = new hdc.Transaction();
          tx.coins = [];
          tx.coins.push(issued.issuer + '-' + id);
          var c = tx.getCoins()[0];
          var amount = c.base * Math.pow(10, c.power);
          coins[amount] = coins[amount] || [];
          coins[amount].push(c);
        });
      });

      var get = {};
      var err = null;
      program.pay.forEach(function (coin) {
        var amount = coin.number; // This is bad name
        amount = parseInt(amount);
        if(coins[amount] && coins[amount].length > 0){
          var c = coins[amount][0];
          get[c.issuer] = get[c.issuer] || [];
          get[c.issuer].push(c);
          coins[amount].splice(0,1); // No more available
        }
        else{
          err = 'You do not have enough coins of value (' + amount + ')';
          return;
        }
      });

      if(err){
        console.error(err);
        return;
      }

      var keys = _(get).keys();
      var str = '';
      keys.sort().reverse();
      keys.forEach(function (key) {
        str += str == '' ? '' : ',';
        str += key;
        get[key].forEach(function (coin) {
          str += ':' + coin.number;
        });
      });
      console.log(str);
    }));
    return;
  }));

program
  .command('issue')
  .description('Send issuance transaction.')
  .action(connect(function (node) {
    if(!program.transaction){
      console.error("Requires --transaction parameter");
      return;
    }
    var tx = fs.readFileSync(program.transaction, 'utf8');
    node.hdc.transactions.processs(tx, proxy(function (res) {
      console.log("Posted issuance transaction");
    }));
    return;
  }));

program
  .command('transfer')
  .description('Send transfer transaction.')
  .action(connect(function (node) {
    if(!program.transaction){
      console.error("Requires --transaction parameter");
      return;
    }
    var tx = fs.readFileSync(program.transaction, 'utf8');
    node.hdc.transactions.processs(tx, proxy(function (res) {
      console.log("Posted transfer transaction");
    }));
    return;
  }));

program
  .command('fusion')
  .description('Send fusion transaction.')
  .action(connect(function (node) {
    if(!program.transaction){
      console.error("Requires --transaction parameter");
      return;
    }
    var tx = fs.readFileSync(program.transaction, 'utf8');
    node.hdc.transactions.processs(tx, proxy(function (res) {
      console.log("Posted fusion transaction");
    }));
    return;
  }));

program
  .command('vote')
  .description('Send vote request.')
  .action(connect(function (node) {
    if(!program.votefile){
      console.error("Requires --votefile parameter");
      return;
    }
    var vote = fs.readFileSync(program.votefile, 'utf8');
    node.hdc.amendments.votes.post(vote, proxy(function (res) {
      console.log("Posted vote for Amendment #" + res.amendment.number);
    }));
    return;
  }));

program
  .command('forge-issuance [am_number]')
  .description('Forge HDC issuance transaction.')
  .action(connect(function (amNumber, node) {
    var tx = new hdc.Transaction();
    var newCoinsStart = 0;
    var am = null;
    async.waterfall([
      function (next){
        // Options control
        if(!program.coins){
          next('You must give at least one coin with --coins option');
          return;
        }
        if(!program.sender){
          next('You must give sender\'s fingerprint with --sender option');
          return;
        }
        next();
      },
      function (next){
        // Find amendment's Dividend and power constraint
        node.hdc.amendments.promoted(amNumber, next);
      },
      function (amTarget, next){
        am = amTarget;
        if(!am.dividend){
          next('No Universal Dividend available on this amendment.');
          return;
        }
        node.ucg.peering.get(next);
      },
      function (peering, next){
        tx.version = "1";
        tx.currency = peering.currency;
        tx.sender = program.sender;
        tx.recipient = tx.sender;
        tx.type = 'ISSUANCE';
        tx.comment = program.comment ? program.comment : '';
        // Find last transaction
        node.hdc.transactions.sender.last(tx.sender, function (err, json) {
          tx.number = err ? 0 : parseInt(json.transaction.number, 10) + 1;
          tx.previousHash = err ? null : sha1(json.raw.unix2dos() + json.signature).toUpperCase();
          next();
        });
      },
      function (next) {
        // Find next issuance coin number
        node.hdc.transactions.sender.issuance.last(tx.sender, function (err, json) {
          if(!err){
            var tmpTX = new hdc.Transaction(json.raw);
            var coins = tmpTX.getCoins();
            newCoinsStart = tmpTX.type == 'ISSUANCE' ? coins[coins.length-1].number + 1 : coins[0].number + 1;
          }
          next();
        });
      },
      function (next){
        // Find already issued from the amendment
        node.hdc.transactions.sender.issuance.dividend.amendment(tx.sender, amNumber, { extract: true }, next);
      },
      function (json, next){
        // Computes the sum and what is left to create
        var sum = 0;
        _(json.leaves).each(function (jsonTX) {
          var aTX = new hdc.Transaction(jsonTX.value.raw);
          aTX.getCoins().forEach(function (coin) {
            sum += coin.base * Math.pow(10, coin.power);
          });
        });
        next(null, am.dividend - sum);
      },
      function (remainder, next) {
        if (remainder <= 0) {
          next('Universal Dividend of this amendment was fully created');
          return;
        }
        tx.coins = [];
        var sum = 0;
        var err = null;
        program.coins.forEach(function (coin) {
          if(!err){
            if(am.coinMinPower && coin.power < am.coinMinPower){
              err = 'Coin must have power > ' + am.coinMinPower;
              return;
            }
            sum += coin.base * Math.pow(10, coin.power);
            tx.coins.push(tx.sender+'-'+newCoinsStart+'-'+coin.base+'-'+coin.power+'-A-'+amNumber);
            newCoinsStart++;
          }
        });
        if(err){
          next(err);
          return;
        }
        if(remainder - sum < 0){
          next('Amount of coins ('+sum+') exceed your remaining Universal Dividend ('+remainder+') for this amendment');
          return;
        }
        next();
      }
    ], function (err, result) {
      if(err){
        console.error(err);
        process.exit(1);
        return;
      }
      console.log(tx.getRaw());
    });
    return;
  }));

program
  .command('forge-fusion')
  .description('Forge HDC fusion transaction.')
  .action(connect(function (node) {
    var tx = new hdc.Transaction();
    var newCoinsStart = 0;
    var am = null;
    async.waterfall([
      function (next){
        // Options control
        if(!program.pay || program.pay.length <= 1){
          next('You must give at least two source coins with --pay option');
          return;
        }
        if(!program.sender){
          next('You must give sender\'s fingerprint with --sender option');
          return;
        }
        next();
      },
      function (next){
        node.ucg.peering.get(next);
      },
      function (peering, next){
        tx.version = "1";
        tx.currency = peering.currency;
        tx.sender = program.sender;
        tx.recipient = tx.sender;
        tx.type = 'FUSION';
        tx.comment = program.comment ? program.comment : '';
        // Find last transaction
        node.hdc.transactions.sender.last(tx.sender, function (err, json) {
          tx.number = err ? 0 : parseInt(json.transaction.number, 10) + 1;
          tx.previousHash = err ? null : sha1(json.raw.unix2dos() + json.signature).toUpperCase();
          next();
        });
      },
      function (next) {
        // Find next issuance coin number
        node.hdc.transactions.sender.issuance.last(tx.sender, function (err, json) {
          if(!err){
            var tmpTX = new hdc.Transaction(json.raw);
            var coins = tmpTX.getCoins();
            newCoinsStart = tmpTX.type == 'ISSUANCE' ? coins[coins.length-1].number + 1 : coins[0].number + 1;
          }
          next();
        });
      },
      function (next){
        tx.coins = [];
        async.forEach(program.pay, function(coin, callback){
          node.hdc.coins.view(coin.issuer, coin.number, function (err, json) {
            if(json.owner != tx.sender){
              callback('Trying to forge a coin you do not own ('+json.id+')');
              return;
            }
            tx.coins.push(json.id + ', ' + json.transaction);
            callback(err);
          });
        }, next);
      },
      function (next){
        var sum = 0;
        tx.getCoins().forEach(function (coin) {
          sum += coin.base * Math.pow(10, coin.power);
        });
        var matches = ("" + sum).match(/^(\d)(0*)$/);
        var fusionCoin = { base: parseInt(matches[1]), power: matches[2].length };
        tx.coins = _([tx.sender+'-'+newCoinsStart+'-'+fusionCoin.base+'-'+fusionCoin.power+'-F-'+tx.number]).union(tx.coins);
        next();
      }
    ], function (err, result) {
      if(err){
        console.error(err);
        process.exit(1);
        return;
      }
      console.log(tx.getRaw());
    });
    return;
  }));

program
  .command('forge-transfer')
  .description('Forge HDC issuance transaction.')
  .action(connect(function (node) {
    var tx = new hdc.Transaction();
    async.waterfall([
      function (next){
        // Options control
        if(!program.pay){
          next('You must give at least one coin with --pay option');
          return;
        }
        if(!program.sender){
          next('You must give sender\'s fingerprint with --sender option');
          return;
        }
        if(!program.recipient){
          next('You must give recipient\'s fingerprint with --recipient option');
          return;
        }
        next();
      },
      function (next){
        node.ucg.peering.get(next);
      },
      function (peering, next){
        tx.version = "1";
        tx.currency = peering.currency;
        tx.sender = program.sender;
        tx.recipient = program.recipient;
        tx.type = 'TRANSFER';
        tx.comment = program.comment ? program.comment : '';
        tx.coins = [];
        // Find last transaction
        node.hdc.transactions.sender.last(tx.sender, function (err, json) {
          tx.number = err ? 0 : parseInt(json.transaction.number, 10) + 1;
          tx.previousHash = err ? null : sha1(json.raw.unix2dos() + json.signature).toUpperCase();
          next();
        });
      },
      function (next) {
        async.forEach(program.pay, function(coin, callback){
          node.hdc.coins.view(coin.issuer, coin.number, function (err, json) {
            tx.coins.push(json.id + ', ' + json.transaction);
            callback(err);
          });
        }, next);
      }
    ], function (err, result) {
      if(err){
        console.error(err);
        process.exit(1);
        return;
      }
      console.log(tx.getRaw());
    });
    return;
  }));

program
  .command('forge-amendment')
  .description('Forge HDC amendment according to uCoin server received data.')
  .action(connect(function (node) {
    var forgedAM = new hdc.Amendment();
    var mapMss = {};
    var mapSig = {};
    var previousVoters = [];
    var membersChanges = toChanges(program.mchanges);
    var votersChanges = toChanges(program.vchanges);
    var membersToAdd = _(membersChanges)
      .filter(filterPlus)
      .map(withoutPlusOrMinus);
    var membersToRemove = _(membersChanges)
      .filter(filterMinus)
      .map(withoutPlusOrMinus);
    var votersToAdd = _(votersChanges)
      .filter(filterPlus)
      .map(withoutPlusOrMinus);
    var votersToRemove = _(votersChanges)
      .filter(filterMinus)
      .map(withoutPlusOrMinus);
    // If any members to add is also to remove
    membersToAdd = _(membersToAdd).difference(membersToRemove);
    async.waterfall([
      function (next){
        // Build an amendment following current amendment of the node
        node.hdc.amendments.current(function (err, am) {
          if(!am){
            // If no amendment, then default
            async.waterfall([
              function (cb){
                node.ucg.peering.get(cb);
              }
            ], function (err, result) {
              next(err, {
                currency: result.currency,
                number: -1,
                votersCount: 0,
                membersCount: 0
              });
            });
            return;
          }
          next(err, am);
        });
      },
      function (am, next){
        forgedAM.version = 1;
        forgedAM.currency = am.currency;
        forgedAM.number = am.number + 1;
        forgedAM.dividend = program.dividend; // If no dividend, field is null hence not taken
        forgedAM.coinMinPower = program.mincoin; // Same as dividend
        forgedAM.nextVotes = program.votes;
        forgedAM.generated = program.timestamp || new Date().getTime();
        if(am.raw){
          forgedAM.previousHash = sha1(am.raw).toUpperCase();
        }
        next(null);
      },
      function (next) {
        // Getting previous amendment members tree
        if (forgedAM.number == 0) {
            next(null, { leaves: [] });
        } else {
          node.hdc.amendments.view.members(forgedAM.number - 1, forgedAM.previousHash, {
            leaves: true
          }, next);
        }
      },
      function (json, next){
        // Computes new members tree
        var members = [];
        var previousMembers = [];
        var reallyAddedMembers = [];
        var reallyRemovedMembers = [];
        // Add previous members
        // console.log(json);
        json.leaves.forEach(function(fingerprint){
          members.push(fingerprint);
          previousMembers.push(fingerprint);
        });
        // Add new members
        membersToAdd.forEach(function(fingerprint){
          members.push(fingerprint);
        });
        members.sort();
        var isSorted = true;
        // Remove eventual duplicates
        members = _(members).uniq(isSorted);
        // Remove members to remove
        members = _(members).difference(membersToRemove);
        reallyAddedMembers = _(members).difference(previousMembers);
        reallyRemovedMembers = _(membersToRemove).difference(members);
        reallyRemovedMembers = _(reallyRemovedMembers).intersection(previousMembers);
        var membersMerkle = merkle(members, 'sha1').process();
        // Writes members changes
        forgedAM.membersChanges = [];
        reallyAddedMembers.forEach(function(fpr){
          forgedAM.membersChanges.push('+' + fpr);
        });
        reallyRemovedMembers.forEach(function(fpr){
          forgedAM.membersChanges.push('-' + fpr);
        });
        forgedAM.membersChanges.sort(); // Important to have a valid amendment
        forgedAM.membersCount = membersMerkle.leaves.length;
        forgedAM.membersRoot = membersMerkle.root();
        next(null);
      },
      function (next) {
        // Getting previous amendment voters tree
        if (forgedAM.number == 0) {
            next(null, { leaves: [] });
        } else {
          node.hdc.amendments.view.voters(forgedAM.number - 1, forgedAM.previousHash, {
            leaves: true
          }, next);
        }
      },
      function (json, next){
        // Computes new voters tree
        var voters = [];
        var previousVoters = [];
        var reallyAddedVoters = [];
        var reallyRemovedVoters = [];
        // Add previous voters
        json.leaves.forEach(function(fingerprint){
          voters.push(fingerprint);
          previousVoters.push(fingerprint);
        });
        // Add new voters
        votersToAdd.forEach(function(fingerprint){
          voters.push(fingerprint);
        });
        voters.sort();
        var isSorted = true;
        // Remove eventual duplicates
        voters = _(voters).uniq(isSorted);
        // Remove voters to remove
        voters = _(voters).difference(votersToRemove);
        reallyAddedVoters = _(voters).difference(previousVoters);
        reallyRemovedVoters = _(votersToRemove).difference(voters);
        var votersMerkle = merkle(voters, 'sha1').process();
        // Writes voters changes
        forgedAM.votersChanges = [];
        reallyAddedVoters.forEach(function(fpr){
          forgedAM.votersChanges.push('+' + fpr);
        });
        reallyRemovedVoters.forEach(function(fpr){
          forgedAM.votersChanges.push('-' + fpr);
        });
        forgedAM.votersChanges.sort(); // Important to have a valid amendment
        forgedAM.votersCount = votersMerkle.leaves.length;
        forgedAM.votersRoot = votersMerkle.root();
        next(null);
      },
    ], function (err, result) {
      console.log(forgedAM.getRaw());
    });
    return;
  }));

program
  .command('index')
  .description('List received votes count for each amendment.')
  .action(connect(function (node) {
    node.hdc.amendments.votes.get(proxy(function (res) {
      _(res.amendments).each(function (ams, number) {
        _(ams).each(function (count, amHash) {
          console.log(number + "-" + amHash + ":" + count);
        });
      });
    }));
    return;
  }));

program.parse(process.argv);

function connect(callback) {
  return function () {
    var cbArgs = arguments;
    vucoin(program.host, program.port, true, function (err, node) {
      if(err){
        console.error(err);
        return;
      }
      cbArgs.length > 0 && cbArgs.length--;
      cbArgs[cbArgs.length++] = node;
      callback.apply(this, cbArgs);
    });
  };
}

function proxy(callback){
  return function (err, res) {
    if(err){
      if(err.code)
        console.error("Error: " + err.code);
      else
        console.error("Error: " + err);
      process.exit(1);
      return;
    }
    else callback(res);
  }
}

function splitCoins (arg) {
  var strings = arg.split(',');
  var values = [];
  for(var i = 0; i < strings.length - 1; i = i + 2){
    values.push({
      base: parseInt(strings[i], 10),
      power: parseInt(strings[i+1], 10)
    });
  }
  return values;
}

function splitCoins2 (arg) {
  var strings = arg.split(',');
  var values = [];
  for(var i = 0; i < strings.length; i++){
    var group = strings[i].split(':');
    var start = strings[0].match(/^[A-Z\d]{40}/) ? 1 : 0;
    for(var j = start; j < group.length; j++){
      if(group[j] && group[j] != ''){
        values.push({
          issuer: start == 1 ? group[0] : '',
          number: group[j]
        });
      }
    }
  }
  return values;
}

function toChanges (str) {
  var changesStr = (str || "")
    .replace(/"/g, '')
    .replace(/\+/g, ';+')
    .replace(/-/g, ';-');
  var changes = [];
  changesStr.split(';').forEach(function(item){
    if (item != "") {
      changes.push(item);
    }
  });
  return changes;
}

function filterPlus (item){
  return item.match(/\+/);
}

function filterMinus (item){
  return item.match(/-/);
}

function withoutPlusOrMinus(item){
  return item.substr(1);
}

String.prototype.trim = function(){
  return this.replace(/^\s+|\s+$/g, '');
};

String.prototype.unix2dos = function(){
  return this.dos2unix().replace(/\n/g, '\r\n');
};

String.prototype.dos2unix = function(){
  return this.replace(/\r\n/g, '\n');
};
