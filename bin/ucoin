#!/usr/bin/env node
var request = require('request');
var program = require('commander');
var vucoin  = require('../index');
var hdc     = require('hdc');
var fs      = require('fs');
var sha1    = require('sha1');
var async   = require('async');
var _       = require('underscore');
var merkle  = require('merkle');

// Default values
program.host = "localhost";
program.port = "8081";

program
  .version('0.1.6')
  .option('--key <keyFile>', 'File of the key to submit.')
  .option('--search <search>', 'Search string')
  .option('--membership <request>', 'Signed membership request file to send.')
  .option('--votefile <voteFile>', 'Vote file to send.')
  .option('-d, --dividend <amount>', 'Universal Dividend amount.', parseInt)
  .option('-m, --mincoin <pow10>', 'New coins minimal 10 power.', parseInt)
  .option('-s, --signature <sigFile>', 'File of a signature to append.')
  .option('-h, --host <address>', 'DNS, IPv4 or IPv6 address of the node to contact.')
  .option('-p, --port <port>', 'Port of the node to contact.')

program
  .command('pks-add')
  .description('Add signed public keys')
  .action(connect(function (node) {
    if(!program.key){
      console.error("Requires --key parameter");
      return;
    }
    var key = fs.readFileSync(program.key, 'utf8');
    var sign = null;
    if(~key.indexOf('-----BEGIN PGP SIGNATURE-----')){
      sign = key.substr(key.indexOf('-----BEGIN PGP SIGNATURE-----'));
      key = key.substr(0, key.indexOf('-----BEGIN PGP SIGNATURE-----'));
    }
    if(~key.indexOf('-----BEGIN PGP MESSAGE-----')){
      sign = key.substr(key.indexOf('-----BEGIN PGP MESSAGE-----'));
      key = key.substr(0, key.indexOf('-----BEGIN PGP MESSAGE-----'));
    }
    else if(program.signature){
      signature = fs.readFileSync(signature, 'utf8');
    }
    if(key && sign){
      node.pks.add(key, sign, proxy(function (res) {
        var name = res.name || '';
        var comment = res.comment ? ' (' + res.comment + ')' : '';
        var email = res.email ? ' <' + res.email + '>' : '';
        console.log("Posted key '" + res.fingerprint + "' of " + name + comment + email);
      }));
    }
    else{
      if(!key){
        console.error("Missing key in given file.");
      }
      if(!sign){
        console.error("Missing signature in given file.");
      }
    }
    return;
  }));

program
  .command('pks-lookup')
  .description('Search for public keys.')
  .action(connect(function (node) {
    if(!program.search){
      console.error("Requires --search parameter");
      return;
    }
    node.pks.lookup(program.search, proxy(function (res) {
      var keys = res.keys;
      console.log("Lookup '" + program.search + "' keys:");
      for (var i = 0; i < keys.length; i++) {
        console.log(keys[i].fingerprint);
      };
    }));
    return;
  }));

program
  .command('peer')
  .description('Show remote peering informations.')
  .action(connect(function (node) {
    node.ucg.peering(proxy(function (res) {
      console.log("Currency: ", res.currency);
      console.log("Public key FPR: ", res.key);
      console.log("Remote host: ", res.remote.host);
      console.log("Remote port: ", res.remote.port);
      console.log("Peers number: ", res.peers.length);
      console.log("Peers list: ");
      res.peers.forEach(function (peer) {
        console.log(JSON.stringify(peer));
      });
    }));
    return;
  }));

program
  .command('am-current')
  .description('View current top amendment of the contract.')
  .action(connect(function (node) {
    node.hdc.amendments.current(proxy(function (res) {
      var amendment = new hdc.Amendment(res.raw);
      console.log(amendment.getRaw());
    }));
    return;
  }));

program
  .command('am-contract')
  .description('View all amendments of the contract.')
  .action(connect(function (node) {
    function getAmendment (number, hash) {
      node.hdc.amendments.view.self(number, hash, proxy(function (res) {
        var amendment = new hdc.Amendment(res.raw);
        console.log(res.raw);
        if(amendment.previousHash){
          getAmendment(amendment.number - 1, amendment.previousHash);
        }
      }));
    }
    node.hdc.amendments.current(proxy(function (res) {
      var amendment = new hdc.Amendment(res.raw);
      console.log(amendment.getRaw());
      if(amendment.previousHash){
        getAmendment(amendment.number - 1, amendment.previousHash);
      }
    }));
    return;
  }));

program
  .command('join')
  .description('Send join membership request.')
  .action(connect(function (node) {
    if(!program.membership){
      console.error("Requires --membership parameter");
      return;
    }
    node.hdc.community.join(program.membership, proxy(function (res) {
      console.log("Posted membership request '" + res.request.status + "' of Amendment #" + res.request.basis);
    }));
    return;
  }));

program
  .command('vote')
  .description('Send vote request.')
  .action(connect(function (node) {
    if(!program.votefile){
      console.error("Requires --votefile parameter");
      return;
    }
    var vote = fs.readFileSync(program.votefile, 'utf8');
    node.hdc.amendments.votes.post(vote, proxy(function (res) {
      console.log("Posted vote for Amendment #" + res.amendment.number);
    }));
    return;
  }));

program
  .command('forge-join')
  .description('Forge HDC membership JOIN request.')
  .action(connect(function (node) {
    forgeMembership('JOIN', node);
    return;
  }));

program
  .command('forge-actu')
  .description('Forge HDC membership ACTUALIZE request.')
  .action(connect(function (node) {
    forgeMembership('ACTUALIZE', node);
    return;
  }));

program
  .command('forge-leave')
  .description('Forge HDC membership LEAVE request.')
  .action(connect(function (node) {
    forgeMembership('LEAVE', node);
    return;
  }));

program
  .command('forge-amendment')
  .description('Forge HDC amendment according to uCoin server received data.')
  .action(connect(function (node) {
    var forgedAM = new hdc.Amendment();
    var mapMss = {};
    var mapSig = {};
    var previousVoters = [];
    async.waterfall([
      function (next){
        node.hdc.amendments.current(function (err, am) {
          if(!am){
            // If no amendment, then default
            async.waterfall([
              function (cb){
                node.ucg.peering(cb);
              }
            ], function (err, result) {
              next(err, {
                currency: result.currency,
                number: -1,
                votersCount: 0,
                membersCount: 0
              });
            });
            return;
          }
          next(err, am);
        });
      },
      function (am, next){
        forgedAM.version = 1;
        forgedAM.currency = am.currency;
        forgedAM.number = am.number + 1;
        forgedAM.dividend = program.dividend;
        forgedAM.coinMinPower = program.mincoin;
        forgedAM.votersCount = am.votersCount;
        forgedAM.membersCount = am.membersCount;
        forgedAM.membersChanges = [];
        forgedAM.votersChanges = [];
        if(am.raw){
          forgedAM.previousHash = sha1(am.raw).toUpperCase();
        }
        next(null);
      },
      function (next) {
        // Previous memberships states
        if(forgedAM.previousHash){
          node.hdc.amendments.view.memberships(
            forgedAM.number - 1,
            forgedAM.previousHash,
            { extract: true }, next);
        }
        else{
          next(null, { merkle: { leaves: [] }});
        }
      },
      function (json, next) {
        // Map previous memberships states
        _(json.merkle.leaves).each(function (obj) {
          if(obj.value.request.status != 'LEAVE')
            mapMss[obj.value.issuer] = obj;
        });
        next(null);
      },
      function (next) {
        // Memberships deltas
        node.hdc.community.memberships({ extract:true }, next);
      },
      function (jsonMSS, next) {
        if(forgedAM.previousHash){
          // Previous memberships states
          node.hdc.amendments.view.members(
            forgedAM.number - 1,
            forgedAM.previousHash,
            { extract: true }, function (err, jsonMS) {
              next(err, jsonMSS, jsonMS);
            });
        }
        else{
          next(null, jsonMSS, { merkle: { leaves: [] }});
        }
      },
      function (jsonMSS, jsonMS, next) {
        var newMss = {};
        var leavingMss = {};
        // Memberships computing
        _(jsonMSS.merkle.leaves).each(function (ms) {
          mapMss[ms.value.issuer] = ms;
          if(ms.value.request.status == 'JOIN')
            newMss[ms.value.issuer] = ms;
          else if(ms.value.request.status == 'LEAVE')
            leavingMss[ms.value.issuer] = ms;
          else if(ms.value.request.status == 'ACTUALIZE'){
          }
          else
            console.error("Bad membership status found:", ms.request.status);
        });
        // Members
        var members = [];
        _(jsonMS.merkle.leaves).each(function (mem) {
          members.push(mem.value);
        });
        var memberships = [];
        _(mapMss).each(function (obj, hash) {
          memberships.push(obj.hash);
        })
        // Memberships + and - deltas (impacts members too)
        var plusChanges = [];
        _(newMss).each(function (obj, hash) {
          plusChanges.push('+' + hash);
          if(members.indexOf(hash) == -1){
            members.push(hash);
          }
        });
        var moinChanges = [];
        _(leavingMss).each(function (obj, hash) {
          moinChanges.push('-' + hash);
          var index = members.indexOf(hash);
          if(~index){
            members.splice(index, 0);
          }
        });
        members.sort();
        memberships.sort();
        var membersMerkle = merkle(members, 'sha1').process();
        var membershipsMerkle = merkle(memberships, 'sha1').process();
        forgedAM.membersChanges = plusChanges.concat(moinChanges);
        forgedAM.membersCount = membersMerkle.leaves.length;
        forgedAM.membersRoot = membersMerkle.root();
        forgedAM.membersStatusRoot = membershipsMerkle.root();
        next(null);
      },
      function (next) {
        // Previous signatures
        node.hdc.amendments.view.signatures(
          forgedAM.number - 1,
          forgedAM.previousHash,
          { extract: true }, next);
      },
      function (json, next) {
        _(json.merkle.leaves).each(function (obj) {
          previousVoters.push(obj.value.issuer);
        });
        next(null);
      },
      function (next) {
        // Signatures of current
        node.hdc.community.votes({ extract:true }, next);
      },
      function (json, next) {
        // Computes + and - deltas
        var voted = [];
        var votes = [];
        _(json.merkle.leaves).each(function (ms) {
          voted.push(ms.value.issuer);
          votes.push(ms.hash);
        });
        var newVoters = _(voted).difference(previousVoters);
        var leavingVoters = _(previousVoters).difference(voted);
        var plusChanges = [];
        newVoters.forEach(function (hash) {
          plusChanges.push('+' + hash);
        });
        var moinChanges = [];
        leavingVoters.forEach(function (hash) {
          moinChanges.push('-' + hash);
        });
        votes.sort();
        voted.sort();
        var votedMerkle = merkle(voted, 'sha1').process();
        var votesMerkle = merkle(votes, 'sha1').process();
        forgedAM.votersChanges = plusChanges.concat(moinChanges);
        forgedAM.votersCount = votesMerkle.leaves.length;
        forgedAM.votersSigRoot = votesMerkle.root();
        forgedAM.votersRoot = votedMerkle.root();
        next(null);
      },
    ], function (err, result) {
      console.log(forgedAM.getRaw());
    });
    return;
  }));

program
  .command('index')
  .description('List received votes count for each amendment.')
  .action(connect(function (node) {
    node.hdc.amendments.votes.get(proxy(function (res) {
      _(res.amendments).each(function (ams, number) {
        _(ams).each(function (count, amHash) {
          console.log(number + "-" + amHash + ":" + count);
        });
      });
    }));
    return;
  }));

program.parse(process.argv);

function connect(callback) {
  return function () {
    var cbArgs = arguments;
    vucoin(program.host, program.port, function (err, node) {
      if(err){
        console.error(err);
        return;
      }
      cbArgs.length--;
      cbArgs[cbArgs.length++] = node;
      callback.apply(this, cbArgs);
    });
  };
}

function forgeMembership (type, node) {
  node.ucg.peering(proxy(function (peering) {
    node.hdc.amendments.current(function (err, am) {
      var number = 0;
      if(am){
        number = am.number + 1;
      }
      var ms = new hdc.Membership();
      ms.version = "1";
      ms.currency = peering.currency;
      ms.basis = number;
      ms.status = type;
      console.log(ms.getRaw());
    });
  }));
}

function proxy(callback){
  return function (err, res) {
    if(err){
      if(err.code)
        console.error("Error: " + err.code);
      else
        console.error("Error: " + err);
      process.exit(1);
      return;
    }
    else callback(res);
  }
}
