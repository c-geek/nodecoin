#!/usr/bin/env node
var request   = require('request');
var program   = require('commander');
var vucoin    = require('../index');
var hdc       = require('hdc');
var fs        = require('fs');
var sha1      = require('sha1');
var async     = require('async');
var _         = require('underscore');
var merkle    = require('merkle');
var Table     = require('cli-table');
var moment    = require('moment');
var inquirer  = require('inquirer');
var mkdirp    = require('mkdirp');
var crypto    = require('../lib/crypto');
var base58    = require('../lib/base58');
var ask       = require('../lib/ask');
var stdinData = '';

// Consts
var NO_AUTH = false;

// Default values
program.host = "localhost";
program.port = "8081";

program
  .version('0.21.1')
  .option('--key <keyFile>', 'File of the key to submit.')
  .option('--search <search>', 'Search string')
  .option('--votefile <voteFile>', 'Vote file to send.')
  .option('--sender <fingerprint>', 'Sender\'s fingerprint.')
  .option('--recipient <fingerprint', 'Recipient\'s fingerprint.')
  .option('--comment <comment>', 'Comment to add to transaction.')
  .option('--transaction <txFile>', 'Transaction file to send.')
  .option('--membership <msFile>', 'Membership file to send.')
  .option('-c, --currency <name>', 'Currency name.')
  .option('-t, --timestamp <timestamp>', 'Timestamp used for GeneratedOn field in amendment.', parseInt)
  .option('-h, --host <address>', 'DNS, IPv4 or IPv6 address of the node to contact.')
  .option('-p, --port <port>', 'Port of the node to contact.')
  .option('--user <user>', 'Alias for storing data in a specific folder. Default to \'default\'')
  .option('--salt <salt>', 'Salt string')
  .option('--passwd <password>', 'Password of the key')
  .option('--store', 'Store data instead of writing to sdout')
  .option('--send', 'send data instead of writing to sdout')
  .option('-y, --yes', 'Do not ask any confirmation')

program
  .command('sec')
  .description('Get base58 secret key using --salt & --password parameters')
  .action(withKeyPair(function (pub, sec) {
    console.log(base58.encode(sec));
  }));

program
  .command('pub')
  .description('Get base58 public key using --salt & --password parameters')
  .action(withKeyPair(function (pub, sec) {
    console.log(base58.encode(pub));
  }));

program
  .command('self [uid]')
  .description('Build self-certification.')
  .action(withKeyPair(function (pub, sec, uid) {
    async.waterfall([
      function (next){
        if (uid) createSelfCert(pub, sec, uid, next);
        else readSelfCert(next);
      },
    ], handleError(function (selfCert) {
      if (program.store)
        writeInHome("self", selfCert);
      if (program.send)
        withConnection(function (node) {
          node.wot.add(base58.encode(pub), selfCert.split('\n').slice(1).join('\n'), '', function (err) {
            if (err) console.error('Error:', err);
            else console.log('Successfully sent identity \'' + uid + '\'');
          })
        })();
      if (!program.send && !program.store)
        process.stdout.write(selfCert);
    }));
  }));

function createSelfCert (pub, sec, uid, done) {
    var raw = "";
    async.waterfall([
      function (next){
        raw += base58.encode(pub) + '\n';
        raw += "UID:" + uid + '\n';
        raw += "META:TS:" + new Date().utcZero().timestamp() + '\n';
        var selfCert = raw.split('\n').slice(1).join('\n');
        crypto.sign(selfCert, sec, next);
      },
      function (sig, next){
        raw += sig + '\n';
        next(null, raw);
      },
    ], done);
}

function readSelfCert (done) {
  done(null, readInHome('self'));
}

program
  .command('join [uid] [certts]')
  .description('Send join membership request.')
  .action(withKeyPair(['currency'], function (pub, sec, uid, certts) {
    async.waterfall([
      function (next){
        if (!uid){
          next('User ID is required');
          return;
        }
        if (certts) {
          next(null, certts);
        } else {
          // Look for possible certts
          async.waterfall([
            function (next) {
              withConnection(function (node){
                node.wot.lookup(decodeURIComponent(uid), next);
              })();
            },
            function (res, next){
              var matches = [];
              var hash = {};
              res.results.forEach(function(pubres){
                matches[pubres.pubkey] = [];
                pubres.uids.forEach(function(uidres){
                  var choice = uidres.meta.timestamp + ' ' + uidres.uid;
                  hash[choice] = uidres.meta.timestamp + ' ' + uidres.uid;
                  matches.push(choice);
                });
              });
              if (matches.length == 0)
                next('No matching identity found on server');
              else {
                if (matches.length == 1)
                  next(null, matches[matches.length-1]);
                else {
                  matches = matches.concat(["None"]);
                  ask.pick("Which one to use for membership?", matches, matches[matches.length-1], function (err, said) {
                    if (said == 'None')
                      next('Aborted.');
                    else
                      next(null, hash[said]);
                  });
                }
              }
            },
          ], next);
        }
      },
      function (ts, next){
        createMembership('IN', pub, sec, uid, ts.split(' ')[0], next);
      },
    ], handleError(function (signedMS) {
      if (program.store)
        writeInHome("join", signedMS);
      if (program.send)
        withConnection(function (node) {
          node.blockchain.membership(signedMS, function (err) {
            if (err) console.error('Error:', err);
            else console.log('Successfully sent join membership.');
          })
        })();
      if (!program.send && !program.store)
        process.stdout.write(signedMS);
    }));
  }));

function createMembership (type, pub, sec, uid, certts, done) {
    var raw = "";
    async.waterfall([
      function (next){
        raw += "Version: 1" + '\n';
        raw += "Currency: " + program.currency + '\n';
        raw += "Issuer: " + base58.encode(pub) + '\n';
        raw += "Date: " + new Date().utcZero().timestamp() + '\n';
        raw += "Membership: " + type + '\n';
        if (uid) {
          raw += "UserID: " + uid + '\n';
        }
        if (certts) {
          raw += "CertTS: " + certts + '\n';
        }
        crypto.sign(raw, sec, next);
      },
      function (sig, next){
        raw += sig + '\n';
        next(null, raw);
      },
    ], done);
}

program
  .command('lookup [search]')
  .description('Show remote pubkey in ASCII armored format.')
  .action(withConnection(function (node, search) {
    async.waterfall([
      function (next){
        node.wot.lookup(search, next);
      },
      function (res, next){
        var matches = [];
        res.results.forEach(function(pubres){
          matches[pubres.pubkey] = [];
          pubres.uids.forEach(function(uidres){
            matches[pubres.pubkey].push(uidres.uid);
          });
        });
        next(null, matches);
      },
    ], handleError(function (res) {
      _(res).keys().forEach(function(pubkey){
        res[pubkey].forEach(function(uid){
          console.log(pubkey + ':' + uid);
        });
      });
    }));
  }));

program
  .command('cert [uid]')
  .description('Certify an identity matching <ui> found on remote server')
  .action(withConnection(function (node, uid) {
    async.waterfall([
      function (next){
        node.wot.lookup(uid, next);
      },
      function (res, next){
        var matches = [];
        var hash = {};
        res.results.forEach(function(pubres){
          pubres.uids.forEach(function(uidres){
            var day = moment.unix(uidres.meta.timestamp);
            var id = [uidres.uid, day.format('lll'), uidres.self.substring(0, 8)].join(' ');
            hash[id] = { pub: pubres.pubkey, uid: uidres.uid, time: uidres.meta.timestamp, sig: uidres.self };
            matches.push(id);
          });
        });
        if (matches.length == 0)
          next('No matching identity found on server');
        else {
          if (matches.length == 1)
            next(null, hash[matches[matches.length-1]]);
          else {
            matches = matches.concat(["None"]);
            ask.pick("Which one to sign?", matches, matches[matches.length-1], function (err, said) {
              if (said == 'None')
                next('Aborted.');
              else
                next(null, hash[said]);
            });
          }
        }
      },
      function (sCert, next){
        var now = moment().unix();
        var toBeSigned = ['UID:' + sCert.uid, 'META:TS:' + sCert.time, sCert.sig, 'META:TS:' + now, ''].join('\n');
        if (program.yes)
          next(null, toBeSigned, now, sCert.pub);
        else {
          console.log('-----------------');
          console.log(toBeSigned);
          console.log('-----------------');
          ask.choose('You are about to sign this identity, continue?', false,
            async.apply(next, null, toBeSigned, now, sCert.pub),
            async.apply(next, 'Aborted.'));
        }
      },
      function (certification, when, sPub, next){
        sign(certification, function (err, sig, pub){
          next(err, certification + sig, pub, when, sPub);
        });
      },
      function (oCert, pub, when, sPub, next){
        var lines = oCert.split('\n');
        var inline = [
          base58.encode(pub),
          sPub,
          when,
          lines.slice(lines.length-1)
        ].join(':') + '\n';
        next(null, inline, sPub, lines.slice(0, 3).join('\n'));
      },
    ], handleError(function (inline, sPub, selfCert) {
      if (program.send)
        node.wot.add(sPub, selfCert, inline, function (err) {
          if (err) console.error('Error:', err);
          else console.log('Successfully sent certification of \'' + uid + '\'');
        })
      if (!program.send && !program.store)
        console.log(inline);
    }));
  }));

function sign (msg, done) {
  async.waterfall([
    function (next){
      if (program.passwd) next(null, program.passwd);
      else ask.password(next);
    },
    function (passwd, next){
      crypto.getKeyPair(passwd, program.salt, next);
    },
    function (pair, next){
      crypto.sign(msg, pair.secretKey, function (err, sig) {
        next(err, sig, pair.publicKey);
      });
    },
  ], done);
}

program
  .command('import-ms [blockNumber] [host] [port]')
  .description('Show remote pubkey in ASCII armored format.')
  .action(withConnection(function (node, blockNumber, host, port) {
    async.waterfall([
      function (next){
        node.blockchain.block(blockNumber, next);
      },
      function (res, next){
        var matches = [];
        var identities = {};
        var joins = {};
        res.identities.forEach(function (idty) {
          var sp = idty.split(':');
          identities[sp[0]] = { pubkey: sp[0], sig: sp[1], time: sp[2], userid: sp[3] };
        });
        res.joiners.forEach(function (join) {
          var sp = join.split(':');
          joins[sp[0]] = { pubkey: sp[0], sig: sp[1], time: sp[2] };
        });
        console.log('Block #%s...', blockNumber);
        async.forEachSeries(res.joiners, function (inlineMS, callback) {
          async.waterfall([
            function (next) {
              var pub = inlineMS.split(':')[0];
              var raw = "";
              raw += "Version: 1" + '\n';
              raw += "Currency: " + res.currency + '\n';
              raw += "Issuer: " + pub + '\n';
              raw += "Date: " + joins[pub].time + '\n';
              raw += "Membership: " + 'IN' + '\n';
              raw += "UserID: " + identities[pub].userid + '\n';
              raw += "CertTS: " + identities[pub].time + '\n';
              raw += joins[pub].sig + '\n';
              vucoin(host, port, function (err, tgtNode) {
                if (err) {
                  console.error(err);
                  process.exit(1);
                }
                tgtNode.blockchain.membership(raw, function (err) {
                  if (err) console.error('Error:', err);
                  else console.log('Successfully sent join membership.');
                });
                next();
              });
            }
          ], callback);
        }, next);
      },
    ], handleError(function (res) {
    }));
  }));

program
  .command('transfer [amount] [recipient]')
  .description('Transfer an amount of coins to a single recipient.')
  .action(withConnectionAndKeyPair(function (node, pub, sec, amount, recipient) {
    var sources = [];
    var currency = '';
    var raw = "";
    async.waterfall([
      function (next) {
        if (!amount || !recipient) {
          next('Amount and recipient are required');
          return;
        }
        node.tx.sources(base58.encode(pub), next);
      },
      function (json, next){
        currency = json.currency;
        var i = 0;
        var cumulated = 0;
        while (cumulated < amount && i < json.sources.length) {
          var src = json.sources[i];
          sources.push({
            'type': src.type,
            'amount': src.amount,
            'number': src.number,
            'hash': src.fingerprint
          });
          cumulated += src.amount;
          i++;
        }
        if (cumulated < amount) {
          next('You do not have enough coins! (' + cumulated + ' ' + currency + ' left)');
        }
        else {
          next();
        }
      },
      function (next){
        var inputSum = 0;
        var issuer = base58.encode(pub);
        raw += "Version: 1" + '\n';
        raw += "Currency: " + currency + '\n';
        raw += "Issuers:\n";
        raw += issuer + '\n';
        raw += "Inputs:\n";
        sources.forEach(function (src) {
          raw += ['0', src.type, src.number, src.hash, src.amount].join(':') + '\n';
          inputSum += src.amount;
        });
        raw += "Outputs:\n";
        raw += [recipient, amount].join(':') + '\n';
        if (inputSum - amount > 0) {
          // Rest back to issuer
          raw += [issuer, inputSum - amount].join(':') + '\n';
        }
        sign(raw, next);
      },
      function (sig, pub, next) {
        raw += sig + '\n';
        console.log(raw);
        node.tx.process(raw, function (err) {
          if (err) console.error('Error:', err);
          else console.log('Successfully sent transaction.');
        });
      },
    ], handleError(function (res) {
    }));
  }));

program
  .command('peer')
  .description('Show remote peering informations.')
  .action(connect(function (node) {
    node.network.peering.get(proxy(function (res) {
      console.log("Currency: %s", res.currency);
      console.log("Public key: %s", res.fingerprint);
      res.endpoints.forEach(function(endpoint, index){
        console.log('Endpoint %s: %s', index, endpoint);
      });
    }));
    return;
  }));

program
  .command('balance [pubkey]')
  .description('Show available sources & computed balance of given pubkey.')
  .action(withConnection(function (node, pubkey) {
    if(!pubkey){
      console.error('pubkey is required');
      return;
    }
    var sources = [];
    async.waterfall([
      function (next) {
        node.tx.sources(pubkey, next);
      },
      function (json, next){
        currency = json.currency;
        var i = 0;
        var cumulated = 0;
        json.sources.forEach(function (src) {
          sources.push({
            'type': src.type,
            'amount': src.amount,
            'number': src.number,
            'hash': src.fingerprint
          });
          cumulated += src.amount;
        });
        console.log("Credit: " + cumulated);
        console.log("-------------------");
        var table = new Table({
          head: ['Value', 'From', 'Source FPR'],
          colWidths: [Math.min(6, (""+cumulated).length + 5), 5, 41],
          chars: {'top': '' , 'top-mid': '' , 'top-left': '' , 'top-right': ''
               , 'bottom': '' , 'bottom-mid': '' , 'bottom-left': '' , 'bottom-right': ''
               , 'left': '' , 'left-mid': '' , 'mid': '' , 'mid-mid': ''
               , 'right': '' , 'right-mid': '' , 'middle': '' },
          style: { 'padding-left': 0, 'padding-right': 0, compact : true }
        });

        sources = _(sources).sort(function (a, b) { return a.amount < b.amount });
        sources.forEach(function (src) {
          table.push([src.amount, src.type, src.hash]);
        });
        console.log(table.toString());
        next();
      },
    ], handleError(function (res) {
    }));
  }));

program
  .command('coins-get [owner]')
  .description('Get a random set of coins with given values, owned by [owner].')
  .action(connect(function (owner, node) {
    if(!owner){
      console.error('owner is required');
      return;
    }
    if(!program.pay){
      console.error("Requires --pay parameter");
      return;
    }
    var coins = {};
    var amendments = {};
    node.hdc.coins.list(owner, proxy(function (res) {
      async.forEachSeries(res.coins, function (id, callback) {
        var tx = new hdc.Transaction();
        tx.coins = [];
        tx.coins.push(id);
        var c = tx.getCoins()[0];
        getAmendment(amendments, c, node, function (err, amount) {
          if (!err) {
            // Coins per value
            coins[amount] = coins[amount] || [];
            coins[amount].push(c);
          }
          callback(err);
        });
      }, function (err) {

        if(err){
          console.error(err);
          return;
        }

        var get = {};
        var err = null;
        program.pay.forEach(function (coin) {
          var amount = parseInt(coin.value);
          if(coins[amount] && coins[amount].length > 0){
            var c = coins[amount][0];
            get[c.issuer] = get[c.issuer] || [];
            get[c.issuer].push(c);
            coins[amount].splice(0,1); // No more available
          }
          else{
            err = 'You do not have enough coins of value (' + amount + ')';
            return;
          }
        });

        if(err){
          console.error(err);
          return;
        }

        var keys = _(get).keys();
        var str = '';
        keys.sort().reverse();
        keys.forEach(function (key) {
          str += str == '' ? '' : ',';
          str += key;
          get[key].forEach(function (coin) {
            str += ':' + [coin.amNumber, coin.coinNumber].join('-');
          });
        });
        console.log(str);
      });
    }));
    return;
  }));

program
  .command('utc-timestamp')
  .description('Get current timestamp for UTC+0 timezone.')
  .action(function () {
    var now = new Date();
    console.log(Math.floor(now.getTime()/1000) + now.getTimezoneOffset()*60);
  });

program.parse(process.argv);

function connect(auth, callback) {
  if (arguments.length == 1) {
    callback = auth;
    auth = true;
  }
  return function () {
    var cbArgs = arguments;
    vucoin(program.host, program.port, function (err, node) {
      if(err){
        console.error(err);
        return;
      }
      cbArgs.length > 0 && cbArgs.length--;
      cbArgs[cbArgs.length++] = node;
      callback.apply(this, cbArgs);
    });
  };
}

function proxy(callback){
  return function (err, res) {
    if(err){
      if(err.code)
        console.error("Error: " + err.code);
      else
        console.error("Error: " + err);
      process.exit(1);
      return;
    }
    else callback(res);
  }
}

function splitCoins (arg) {
  var strings = arg.split(',');
  var values = [];
  for(var i = 0; i < strings.length - 1; i = i + 2){
    values.push({
      base: parseInt(strings[i], 10),
      power: parseInt(strings[i+1], 10)
    });
  }
  return values;
}

function getLastIssuedCoin(tx) {
  if (tx.type == 'ISSUANCE') {
    // Get last coin of the list
    var coins = tx.getCoins();
    return coins[coins.length - 1];
  } else if (tx.type == 'CHANGE') {
    // Get last coin of the list with no TRANSACTION_ID
    var coins = tx.getCoins();
    var lastCoin = null;
    var i = 0;
    while (coins[i] && !coins[i].transaction) {
      lastCoin = coins[i];
      i++;
    }
    return lastCoin;
  } else {
    // No issued coin exists
    return null;
  }
}

function toChanges (str) {
  var changesStr = (str || "")
    .replace(/"/g, '')
    .replace(/\+/g, ';+')
    .replace(/-/g, ';-');
  var changes = [];
  changesStr.split(';').forEach(function(item){
    if (item != "") {
      changes.push(item);
    }
  });
  return changes;
}

function filterPlus (item){
  return item.match(/\+/);
}

function filterMinus (item){
  return item.match(/-/);
}

function withoutPlusOrMinus(item){
  return item.substr(1);
}

function getAmendment (amendments, c, node, done) {
  async.waterfall([
    function (next){
      if (amendments[c.amNumber]) {
        next(null, amendments[c.amNumber]);
      } else {
        node.hdc.amendments.promoted(c.amNumber, proxy(function (res) {
          amendments[c.amNumber] = res;
          next(null, amendments[c.amNumber]);
        }));
      }
    },
    function (am, next){
      done(null, coinValue(c.coinNumber, am));
    },
  ], done);
}

function coinValue (coinNumber, am) {
  var power = am.coinBase;
  var decr = coinNumber;
  am.coinList.forEach(function(quantity){
    if (decr <= quantity) {
      return;
    }
    decr -= quantity;
    power++;
  });
  return Math.pow(2, power);
}

function handleError (success) {
  return function () {
    if (arguments[0])
      console.error(arguments[0]);
    else {
      var args = Array.prototype.slice.call(arguments);
      success.apply(success, args.slice(1));
    }
  };
}

function withKeyPair (parameters, done) {
  if (arguments.length == 1) {
    done = parameters;
    parameters = [];
  }
  return withParams(['salt', 'passwd'].concat(parameters), function () {
    var args = Array.prototype.slice.call(arguments);
    crypto.getKeyPair(program.passwd, program.salt, function (err, pair) {
      done.apply(done, [pair.publicKey, pair.secretKey].concat(args));
    });
  });
}

function withConnection (parameters, done) {
  if (arguments.length == 1) {
    done = parameters;
    parameters = [];
  }
  return withParams(['host', 'port'].concat(parameters), function () {
    var args = Array.prototype.slice.call(arguments);
    vucoin(program.host, program.port, function (err, node) {
      if (err) {
        console.error(err);
        process.exit(1);
      }
      done.apply(done, [node].concat(args));
    });
  });
}

function withConnectionAndKeyPair (parameters, done) {
  if (arguments.length == 1) {
    done = parameters;
    parameters = [];
  }
  return withParams(['host', 'port', 'salt', 'passwd'].concat(parameters), function () {
    var args = Array.prototype.slice.call(arguments);
    async.parallel({
      node: function (next) {
        vucoin(program.host, program.port, function (err, node) {
          if (err) {
            console.error(err);
            process.exit(1);
          }
          next.apply(next, [null, node]);
        });
      },
      keys: function (next) {
        crypto.getKeyPair(program.passwd, program.salt, function (err, pair) {
          next.apply(next, [null, pair.publicKey, pair.secretKey]);
        });
      }
    }, function (err, res) {
      done.apply(done, [res.node].concat(res.keys).concat(args));
    });
  });
}

function withParams (parameters, done) {
  return function () {
    var err = null;
    parameters.forEach(function(p){
      if(!err && !program[p]){
        err = "Requires --" + p + " parameter";
      }
    });
    if (err) {
      console.error(err);
      process.exit(1);
    }
    done.apply(done, arguments);
  };
}

function writeInHome (fileName, content) {
  var homePath = process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE;
  var ucoinPath = homePath + '/.ucoin/' + (program.user ? program.user : 'defaut');
  mkdirp.sync(ucoinPath, '0770');
  fs.writeFileSync(ucoinPath + '/' + fileName, content, 'utf8');
}

function readInHome (fileName) {
  var homePath = process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE;
  var ucoinPath = homePath + '/.ucoin/' + (program.user ? program.user : 'defaut');
  var filePath = ucoinPath + '/' + fileName;
  return fs.existsSync(filePath) ? fs.readFileSync(filePath, 'utf8') : '';
}

function split (pattern) {
  return function (str) {
    return str.split(pattern);
  };
}

String.prototype.trim = function(){
  return this.replace(/^\s+|\s+$/g, '');
};

String.prototype.unix2dos = function(){
  return this.dos2unix().replace(/\n/g, '\r\n');
};

String.prototype.dos2unix = function(){
  return this.replace(/\r\n/g, '\n');
};

String.prototype.coin = function(){
  var matches = this.match(/([A-Z\d]{40})-(\d+)-(\d+)(:([A-Z\d]{40})-(\d+))?/);
  if(matches && matches.length == 7){
    return {
      issuer: matches[1],
      amNumber: parseInt(matches[2], 10),
      coinNumber: parseInt(matches[3], 10),
      transaction: matches[4] && {
        sender: matches[5],
        number: matches[6]
      }
    };
  } else {
    return null;
  }
};

Date.prototype.utc = function(){
  return new Date();
};

Date.prototype.utcZero = function(){
  return new Date(this.getTime() + this.getTimezoneOffset()*60*1000);
};

Date.prototype.timestamp = function(){
  return Math.floor(this.getTime() / 1000);
};
