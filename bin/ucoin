#!/usr/bin/env node
var request = require('request');
var program = require('commander');
var vucoin  = require('../index');
var hdc     = require('hdc');
var fs      = require('fs');
var sha1    = require('sha1');
var async   = require('async');
var _       = require('underscore');
var merkle  = require('merkle');
var Table   = require('cli-table');

// Default values
program.host = "localhost";
program.port = "8081";

program
  .version('0.2.11')
  .option('--key <keyFile>', 'File of the key to submit.')
  .option('--search <search>', 'Search string')
  .option('--membership <request>', 'Signed membership request file to send.')
  .option('--votefile <voteFile>', 'Vote file to send.')
  .option('--coins <base,power[,...]>', 'Coins to create.', splitCoins)
  .option('--pay <issuer,number[,...]>', 'Coins to transfert.', splitCoins2)
  .option('--sender <fingerprint>', 'Sender\'s fingerprint.')
  .option('--recipient <fingerprint', 'Recipient\'s fingerprint.')
  .option('--comment <comment>', 'Comment to add to transaction.')
  .option('--transaction <txFile>', 'Transaction file to send.')
  .option('-d, --dividend <amount>', 'Universal Dividend amount.', parseInt)
  .option('-m, --mincoin <pow10>', 'New coins minimal 10 power.', parseInt)
  .option('-s, --signature <sigFile>', 'File of a signature to append.')
  .option('-h, --host <address>', 'DNS, IPv4 or IPv6 address of the node to contact.')
  .option('-p, --port <port>', 'Port of the node to contact.')

program
  .command('pubkey')
  .description('Show remote pubkey in ASCII armored format.')
  .action(connect(function (node) {
    node.ucg.pubkey(proxy(function (res) {
      console.log(res);
    }));
    return;
  }));

program
  .command('pks-add')
  .description('Add signed public keys')
  .action(connect(function (node) {
    if(!program.key){
      console.error("Requires --key parameter");
      return;
    }
    var key = fs.readFileSync(program.key, 'utf8');
    var sign = null;
    if(~key.indexOf('-----BEGIN PGP SIGNATURE-----')){
      sign = key.substr(key.indexOf('-----BEGIN PGP SIGNATURE-----'));
      key = key.substr(0, key.indexOf('-----BEGIN PGP SIGNATURE-----'));
    }
    if(~key.indexOf('-----BEGIN PGP MESSAGE-----')){
      sign = key.substr(key.indexOf('-----BEGIN PGP MESSAGE-----'));
      key = key.substr(0, key.indexOf('-----BEGIN PGP MESSAGE-----'));
    }
    else if(program.signature){
      signature = fs.readFileSync(signature, 'utf8');
    }
    if(key && sign){
      node.pks.add(key, sign, proxy(function (res) {
        var name = res.name || '';
        var comment = res.comment ? ' (' + res.comment + ')' : '';
        var email = res.email ? ' <' + res.email + '>' : '';
        console.log("Posted key '" + res.fingerprint + "' of " + name + comment + email);
      }));
    }
    else{
      if(!key){
        console.error("Missing key in given file.");
      }
      if(!sign){
        console.error("Missing signature in given file.");
      }
    }
    return;
  }));

program
  .command('pks-lookup')
  .description('Search for public keys.')
  .action(connect(function (node) {
    if(!program.search){
      console.error("Requires --search parameter");
      return;
    }
    node.pks.lookup(program.search, proxy(function (res) {
      var keys = res.keys;
      console.log("Lookup '" + program.search + "' keys:");
      for (var i = 0; i < keys.length; i++) {
        console.log(keys[i].fingerprint);
      };
    }));
    return;
  }));

program
  .command('peer')
  .description('Show remote peering informations.')
  .action(connect(function (node) {
    node.ucg.peering.get(proxy(function (res) {
      console.log("Currency: %s", res.currency);
      console.log("Public key FPR: %s", res.key);
      console.log("Contract: %s", res.contract.currentNumber == '' ? 'none' : res.contract.currentNumber + '-' + res.contract.hash);
      console.log("Public keys: %s", res["pks/all"].merkle.leavesCount);
      res.remote.host != '' && console.log("Remote host: %s", res.remote.host);
      res.remote.ipv4 != '' && console.log("Remote ipv4: %s", res.remote.ipv4);
      res.remote.ipv6 != '' && console.log("Remote ipv6: %s", res.remote.ipv6);
      res.remote.port != null && console.log("Remote port: %s", res.remote.port);
    }));
    return;
  }));

program
  .command('am-current')
  .description('View current top amendment of the contract.')
  .action(connect(function (node) {
    node.hdc.amendments.current(proxy(function (res) {
      var amendment = new hdc.Amendment(res.raw);
      console.log(amendment.getRaw());
    }));
    return;
  }));

program
  .command('am-contract')
  .description('View all amendments of the contract.')
  .action(connect(function (node) {
    function getAmendment (number, hash) {
      node.hdc.amendments.view.self(number, hash, proxy(function (res) {
        var amendment = new hdc.Amendment(res.raw);
        console.log(res.raw);
        if(amendment.previousHash){
          getAmendment(amendment.number - 1, amendment.previousHash);
        }
      }));
    }
    node.hdc.amendments.current(proxy(function (res) {
      var amendment = new hdc.Amendment(res.raw);
      console.log(amendment.getRaw());
      if(amendment.previousHash){
        getAmendment(amendment.number - 1, amendment.previousHash);
      }
    }));
    return;
  }));

program
  .command('tx-show-last [count]')
  .description('Show last [count] transactions (default to one).')
  .action(connect(function (count, node) {
    count = count || 1;
    node.hdc.transactions.lasts(count, proxy(function (res) {
      res.transactions.forEach(function (tx) {
        var hdxTX = new hdc.Transaction();
        _(hdxTX).keys().forEach(function (key) {
          if(tx[key]){
            hdxTX[key] = tx[key];
          }
        });
        hdxTX.coins = [];
        tx.coins.forEach(function (coin) {
          hdxTX.coins.push(coin.id + ', ' + coin.transaction_id);
        })
        console.log(hdxTX.getRaw());
      })
    }));
    return;
  }));

program
  .command('tx-sender-show-last [count]')
  .description('Show last [count] transactions of sender (default to one).')
  .action(connect(function (count, node) {
    count = count || 1;
    if(!program.sender){
      console.error("Requires --sender parameter");
      return;
    }
    node.hdc.transactions.sender.lasts(program.sender, count, proxy(function (res) {
      res.transactions.forEach(function (tx) {
        var hdxTX = new hdc.Transaction();
        _(hdxTX).keys().forEach(function (key) {
          if(tx[key]){
            hdxTX[key] = tx[key];
          }
        });
        hdxTX.coins = [];
        tx.coins.forEach(function (coin) {
          hdxTX.coins.push(coin.id + ', ' + coin.transaction_id);
        })
        console.log(hdxTX.getRaw());
      })
    }));
    return;
  }));

program
  .command('coins-list [owner] [upperlimit]')
  .description('Show coins of given owner, whose value is under [upperlimit].')
  .action(connect(function (owner, upperlimit, node) {
    if(!owner){
      console.error('owner is required');
      return;
    }
    upperlimit = upperlimit ? parseInt(upperlimit) : null;
    var coins = {};
    node.hdc.coins.list(owner, proxy(function (res) {
      var sum = 0;
      res.coins.forEach(function (issued) {
        issued.ids.forEach(function (id) {
          var tx = new hdc.Transaction();
          tx.coins = [];
          tx.coins.push(issued.issuer + '-' + id);
          var c = tx.getCoins()[0];
          var amount = c.base * Math.pow(10, c.power);
          if(!upperlimit || upperlimit >= amount){
            coins[amount] = coins[amount] || [];
            coins[amount].push(c);
            sum += amount;
          }
        });
      });
      console.log("Credit: " + sum);
      console.log("-------------------");
      var table = new Table({
        head: ['Value', 'Issuer', '#'],
        colWidths: [Math.min(6, (""+sum).length + 5), 41, 10],
        chars: { 'top': '' , 'top-mid': '' , 'top-left': '' , 'top-right': ''
             , 'bottom': '' , 'bottom-mid': '' , 'bottom-left': '' , 'bottom-right': ''
             , 'left': '' , 'left-mid': '' , 'mid': '' , 'mid-mid': ''
             , 'right': '' , 'right-mid': '' , 'middle': '' },
        style: { 'padding-left': 0, 'padding-right': 0, compact : true }
      });

      var keys = _(coins).keys();
      keys.sort().reverse();
      keys.forEach(function (key) {
        coins[key].forEach(function (coin) {
          table.push([key, coin.issuer, coin.number]);
        });
      });
      console.log(table.toString());
    }));
    return;
  }));

program
  .command('coins-get [owner]')
  .description('Get a random set of coins with given values, owned by [owner].')
  .action(connect(function (owner, node) {
    if(!owner){
      console.error('owner is required');
      return;
    }
    if(!program.pay){
      console.error("Requires --pay parameter");
      return;
    }
    var coins = {};
    node.hdc.coins.list(owner, proxy(function (res) {
      res.coins.forEach(function (issued) {
        issued.ids.forEach(function (id) {
          var tx = new hdc.Transaction();
          tx.coins = [];
          tx.coins.push(issued.issuer + '-' + id);
          var c = tx.getCoins()[0];
          var amount = c.base * Math.pow(10, c.power);
          coins[amount] = coins[amount] || [];
          coins[amount].push(c);
        });
      });

      var get = {};
      var err = null;
      program.pay.forEach(function (coin) {
        var amount = coin.number; // This is bad name
        amount = parseInt(amount);
        if(coins[amount] && coins[amount].length > 0){
          var c = coins[amount][0];
          get[c.issuer] = get[c.issuer] || [];
          get[c.issuer].push(c);
          coins[amount].splice(0,1); // No more available
        }
        else{
          err = 'You do not have enough coins of value (' + amount + ')';
          return;
        }
      });

      if(err){
        console.error(err);
        return;
      }

      var keys = _(get).keys();
      var str = '';
      keys.sort().reverse();
      keys.forEach(function (key) {
        str += str == '' ? '' : ',';
        str += key;
        get[key].forEach(function (coin) {
          str += ':' + coin.number;
        });
      });
      console.log(str);
    }));
    return;
  }));

program
  .command('issue')
  .description('Send issuance transaction.')
  .action(connect(function (node) {
    if(!program.transaction){
      console.error("Requires --transaction parameter");
      return;
    }
    var tx = fs.readFileSync(program.transaction, 'utf8');
    node.hdc.transactions.processs(tx, proxy(function (res) {
      console.log("Posted issuance transaction");
    }));
    return;
  }));

program
  .command('transfert')
  .description('Send transfert transaction.')
  .action(connect(function (node) {
    if(!program.transaction){
      console.error("Requires --transaction parameter");
      return;
    }
    var tx = fs.readFileSync(program.transaction, 'utf8');
    node.hdc.transactions.processs(tx, proxy(function (res) {
      console.log("Posted transfert transaction");
    }));
    return;
  }));

program
  .command('fusion')
  .description('Send fusion transaction.')
  .action(connect(function (node) {
    if(!program.transaction){
      console.error("Requires --transaction parameter");
      return;
    }
    var tx = fs.readFileSync(program.transaction, 'utf8');
    node.hdc.transactions.processs(tx, proxy(function (res) {
      console.log("Posted fusion transaction");
    }));
    return;
  }));

program
  .command('join')
  .description('Send join membership request.')
  .action(connect(function (node) {
    if(!program.membership){
      console.error("Requires --membership parameter");
      return;
    }
    node.hdc.community.join(program.membership, proxy(function (res) {
      console.log("Posted membership request '" + res.request.status + "' of Amendment #" + res.request.basis);
    }));
    return;
  }));

program
  .command('vote')
  .description('Send vote request.')
  .action(connect(function (node) {
    if(!program.votefile){
      console.error("Requires --votefile parameter");
      return;
    }
    var vote = fs.readFileSync(program.votefile, 'utf8');
    node.hdc.amendments.votes.post(vote, proxy(function (res) {
      console.log("Posted vote for Amendment #" + res.amendment.number);
    }));
    return;
  }));

program
  .command('forge-issuance [am_number]')
  .description('Forge HDC issuance transaction.')
  .action(connect(function (amNumber, node) {
    var tx = new hdc.Transaction();
    var newCoinsStart = 0;
    var am = null;
    async.waterfall([
      function (next){
        // Options control
        if(!program.coins){
          next('You must give at least one coin with --coins option');
          return;
        }
        if(!program.sender){
          next('You must give sender\'s fingerprint with --sender option');
          return;
        }
        next();
      },
      function (next){
        // Find amendment's Dividend and power constraint
        node.hdc.amendments.promoted(amNumber, next);
      },
      function (amTarget, next){
        am = amTarget;
        if(!am.dividend){
          next('No Universal Dividend available on this amendment.');
          return;
        }
        node.ucg.peering.get(next);
      },
      function (peering, next){
        tx.version = "1";
        tx.currency = peering.currency;
        tx.sender = program.sender;
        tx.recipient = tx.sender;
        tx.type = 'ISSUANCE';
        tx.comment = program.comment ? program.comment : '';
        // Find last transaction
        node.hdc.transactions.sender.last(tx.sender, function (err, json) {
          tx.number = err ? 0 : parseInt(json.transaction.number, 10) + 1;
          tx.previousHash = err ? null : sha1(json.raw.unix2dos() + json.signature).toUpperCase();
          next();
        });
      },
      function (next) {
        // Find next issuance coin number
        node.hdc.transactions.sender.issuance.last(tx.sender, function (err, json) {
          if(!err){
            var tmpTX = new hdc.Transaction(json.raw);
            var coins = tmpTX.getCoins();
            newCoinsStart = tmpTX.type == 'ISSUANCE' ? coins[coins.length-1].number + 1 : coins[0].number + 1;
          }
          next();
        });
      },
      function (next){
        // Find already issued from the amendment
        node.hdc.transactions.sender.issuance.dividend.amendment(tx.sender, amNumber, { extract: true }, next);
      },
      function (json, next){
        // Computes the sum and what is left to create
        var sum = 0;
        _(json.leaves).each(function (jsonTX) {
          var aTX = new hdc.Transaction(jsonTX.value.raw);
          aTX.getCoins().forEach(function (coin) {
            sum += coin.base * Math.pow(10, coin.power);
          });
        });
        next(null, am.dividend - sum);
      },
      function (remainder, next) {
        if (remainder <= 0) {
          next('Universal Dividend of this amendment was fully created');
          return;
        }
        tx.coins = [];
        var sum = 0;
        var err = null;
        program.coins.forEach(function (coin) {
          if(!err){
            if(am.coinMinPower && coin.power < am.coinMinPower){
              err = 'Coin must have power > ' + am.coinMinPower;
              return;
            }
            sum += coin.base * Math.pow(10, coin.power);
            tx.coins.push(tx.sender+'-'+newCoinsStart+'-'+coin.base+'-'+coin.power+'-A-'+amNumber);
            newCoinsStart++;
          }
        });
        if(err){
          next(err);
          return;
        }
        if(remainder - sum < 0){
          next('Amount of coins ('+sum+') exceed your remaining Universal Dividend ('+remainder+') for this amendment');
          return;
        }
        next();
      }
    ], function (err, result) {
      if(err){
        console.error(err);
        process.exit(1);
        return;
      }
      console.log(tx.getRaw());
    });
    return;
  }));

program
  .command('forge-fusion')
  .description('Forge HDC fusion transaction.')
  .action(connect(function (node) {
    var tx = new hdc.Transaction();
    var newCoinsStart = 0;
    var am = null;
    async.waterfall([
      function (next){
        // Options control
        if(!program.pay || program.pay.length <= 1){
          next('You must give at least two source coins with --pay option');
          return;
        }
        if(!program.sender){
          next('You must give sender\'s fingerprint with --sender option');
          return;
        }
        next();
      },
      function (next){
        node.ucg.peering.get(next);
      },
      function (peering, next){
        tx.version = "1";
        tx.currency = peering.currency;
        tx.sender = program.sender;
        tx.recipient = tx.sender;
        tx.type = 'FUSION';
        tx.comment = program.comment ? program.comment : '';
        // Find last transaction
        node.hdc.transactions.sender.last(tx.sender, function (err, json) {
          tx.number = err ? 0 : parseInt(json.transaction.number, 10) + 1;
          tx.previousHash = err ? null : sha1(json.raw.unix2dos() + json.signature).toUpperCase();
          next();
        });
      },
      function (next) {
        // Find next issuance coin number
        node.hdc.transactions.sender.issuance.last(tx.sender, function (err, json) {
          if(!err){
            var tmpTX = new hdc.Transaction(json.raw);
            var coins = tmpTX.getCoins();
            newCoinsStart = tmpTX.type == 'ISSUANCE' ? coins[coins.length-1].number + 1 : coins[0].number + 1;
          }
          next();
        });
      },
      function (next){
        tx.coins = [];
        async.forEach(program.pay, function(coin, callback){
          node.hdc.coins.view(coin.issuer, coin.number, function (err, json) {
            if(json.owner != tx.sender){
              callback('Trying to forge a coin you do not own ('+json.id+')');
              return;
            }
            tx.coins.push(json.id + ', ' + json.transaction);
            callback(err);
          });
        }, next);
      },
      function (next){
        var sum = 0;
        tx.getCoins().forEach(function (coin) {
          sum += coin.base * Math.pow(10, coin.power);
        });
        var matches = ("" + sum).match(/^(\d)(0*)$/);
        var fusionCoin = { base: parseInt(matches[1]), power: matches[2].length };
        tx.coins = _([tx.sender+'-'+newCoinsStart+'-'+fusionCoin.base+'-'+fusionCoin.power+'-F-'+tx.number]).union(tx.coins);
        next();
      }
    ], function (err, result) {
      if(err){
        console.error(err);
        process.exit(1);
        return;
      }
      console.log(tx.getRaw());
    });
    return;
  }));

program
  .command('forge-transfert')
  .description('Forge HDC issuance transaction.')
  .action(connect(function (node) {
    var tx = new hdc.Transaction();
    async.waterfall([
      function (next){
        // Options control
        if(!program.pay){
          next('You must give at least one coin with --pay option');
          return;
        }
        if(!program.sender){
          next('You must give sender\'s fingerprint with --sender option');
          return;
        }
        if(!program.recipient){
          next('You must give recipient\'s fingerprint with --recipient option');
          return;
        }
        next();
      },
      function (next){
        node.ucg.peering.get(next);
      },
      function (peering, next){
        tx.version = "1";
        tx.currency = peering.currency;
        tx.sender = program.sender;
        tx.recipient = program.recipient;
        tx.type = 'TRANSFERT';
        tx.comment = program.comment ? program.comment : '';
        tx.coins = [];
        // Find last transaction
        node.hdc.transactions.sender.last(tx.sender, function (err, json) {
          tx.number = err ? 0 : parseInt(json.transaction.number, 10) + 1;
          tx.previousHash = err ? null : sha1(json.raw.unix2dos() + json.signature).toUpperCase();
          next();
        });
      },
      function (next) {
        async.forEach(program.pay, function(coin, callback){
          node.hdc.coins.view(coin.issuer, coin.number, function (err, json) {
            tx.coins.push(json.id + ', ' + json.transaction);
            callback(err);
          });
        }, next);
      }
    ], function (err, result) {
      if(err){
        console.error(err);
        process.exit(1);
        return;
      }
      console.log(tx.getRaw());
    });
    return;
  }));

program
  .command('forge-join')
  .description('Forge HDC membership JOIN request.')
  .action(connect(function (node) {
    forgeMembership('JOIN', node);
    return;
  }));

program
  .command('forge-actu')
  .description('Forge HDC membership ACTUALIZE request.')
  .action(connect(function (node) {
    forgeMembership('ACTUALIZE', node);
    return;
  }));

program
  .command('forge-leave')
  .description('Forge HDC membership LEAVE request.')
  .action(connect(function (node) {
    forgeMembership('LEAVE', node);
    return;
  }));

program
  .command('forge-amendment')
  .description('Forge HDC amendment according to uCoin server received data.')
  .action(connect(function (node) {
    var forgedAM = new hdc.Amendment();
    var mapMss = {};
    var mapSig = {};
    var previousVoters = [];
    async.waterfall([
      function (next){
        node.hdc.amendments.current(function (err, am) {
          if(!am){
            // If no amendment, then default
            async.waterfall([
              function (cb){
                node.ucg.peering.get(cb);
              }
            ], function (err, result) {
              next(err, {
                currency: result.currency,
                number: -1,
                votersCount: 0,
                membersCount: 0
              });
            });
            return;
          }
          next(err, am);
        });
      },
      function (am, next){
        forgedAM.version = 1;
        forgedAM.currency = am.currency;
        forgedAM.number = am.number + 1;
        forgedAM.dividend = program.dividend;
        forgedAM.coinMinPower = program.mincoin;
        forgedAM.votersCount = am.votersCount;
        forgedAM.membersCount = am.membersCount;
        forgedAM.membersChanges = [];
        forgedAM.votersChanges = [];
        if(am.raw){
          forgedAM.previousHash = sha1(am.raw).toUpperCase();
        }
        next(null);
      },
      function (next) {
        // Previous memberships states
        if(forgedAM.previousHash){
          node.hdc.amendments.view.memberships(
            forgedAM.number - 1,
            forgedAM.previousHash,
            { extract: true }, next);
        }
        else{
          next(null, { merkle: { leaves: [] }});
        }
      },
      function (json, next) {
        // Map previous memberships states
        _(json.leaves).each(function (obj) {
          if(obj.value.request.status != 'LEAVE')
            mapMss[obj.value.issuer] = obj;
        });
        next(null);
      },
      function (next) {
        // Memberships deltas
        node.hdc.community.memberships({ extract:true }, next);
      },
      function (jsonMSS, next) {
        if(forgedAM.previousHash){
          // Previous memberships states
          node.hdc.amendments.view.members(
            forgedAM.number - 1,
            forgedAM.previousHash,
            { extract: true }, function (err, jsonMS) {
              next(err, jsonMSS, jsonMS);
            });
        }
        else{
          next(null, jsonMSS, { merkle: { leaves: [] }});
        }
      },
      function (jsonMSS, jsonMS, next) {
        var newMss = {};
        var leavingMss = {};
        // Memberships computing
        _(jsonMSS.merkle.leaves).each(function (ms) {
          if(ms.value.request.basis == forgedAM.number){
            mapMss[ms.value.issuer] = ms;
            if(ms.value.request.status == 'JOIN')
              newMss[ms.value.issuer] = ms;
            else if(ms.value.request.status == 'LEAVE')
              leavingMss[ms.value.issuer] = ms;
            else if(ms.value.request.status == 'ACTUALIZE'){
            }
            else
              console.error("Bad membership status found:", ms.request.status);
          }
        });
        // Members
        var members = [];
        _(jsonMS.merkle.leaves).each(function (mem) {
          members.push(mem.value);
        });
        var memberships = [];
        _(mapMss).each(function (obj, hash) {
          memberships.push(obj.hash);
        })
        // Memberships + and - deltas (impacts members too)
        var plusChanges = [];
        _(newMss).each(function (obj, hash) {
          plusChanges.push('+' + hash);
          if(members.indexOf(hash) == -1){
            members.push(hash);
          }
        });
        var moinChanges = [];
        _(leavingMss).each(function (obj, hash) {
          moinChanges.push('-' + hash);
          var index = members.indexOf(hash);
          if(~index){
            members.splice(index, 0);
          }
        });
        members.sort();
        memberships.sort();
        var membersMerkle = merkle(members, 'sha1').process();
        var membershipsMerkle = merkle(memberships, 'sha1').process();
        forgedAM.membersChanges = plusChanges.concat(moinChanges);
        forgedAM.membersCount = membersMerkle.leaves.length;
        forgedAM.membersRoot = membersMerkle.root();
        forgedAM.membersStatusRoot = membershipsMerkle.root();
        next(null);
      },
      function (next) {
        // Previous signatures
        node.hdc.amendments.view.signatures(
          forgedAM.number - 1,
          forgedAM.previousHash,
          { extract: true }, next);
      },
      function (json, next) {
        _(json.leaves).each(function (obj) {
          previousVoters.push(obj.value.issuer);
        });
        next(null);
      },
      function (next) {
        // Signatures of current
        node.hdc.community.votes({ extract:true }, next);
      },
      function (json, next) {
        // Computes + and - deltas
        var voted = [];
        var votes = [];
        _(json.leaves).each(function (ms) {
          voted.push(ms.value.issuer);
          votes.push(ms.hash);
        });
        var newVoters = _(voted).difference(previousVoters);
        var leavingVoters = _(previousVoters).difference(voted);
        var plusChanges = [];
        newVoters.forEach(function (hash) {
          plusChanges.push('+' + hash);
        });
        var moinChanges = [];
        leavingVoters.forEach(function (hash) {
          moinChanges.push('-' + hash);
        });
        votes.sort();
        voted.sort();
        var votedMerkle = merkle(voted, 'sha1').process();
        var votesMerkle = merkle(votes, 'sha1').process();
        forgedAM.votersChanges = plusChanges.concat(moinChanges);
        forgedAM.votersCount = votesMerkle.leaves.length;
        forgedAM.votersSigRoot = votesMerkle.root();
        forgedAM.votersRoot = votedMerkle.root();
        next(null);
      },
    ], function (err, result) {
      console.log(forgedAM.getRaw());
    });
    return;
  }));

program
  .command('index')
  .description('List received votes count for each amendment.')
  .action(connect(function (node) {
    node.hdc.amendments.votes.get(proxy(function (res) {
      _(res.amendments).each(function (ams, number) {
        _(ams).each(function (count, amHash) {
          console.log(number + "-" + amHash + ":" + count);
        });
      });
    }));
    return;
  }));

program.parse(process.argv);

function connect(callback) {
  return function () {
    var cbArgs = arguments;
    vucoin(program.host, program.port, true, function (err, node) {
      if(err){
        console.error(err);
        return;
      }
      cbArgs.length--;
      cbArgs[cbArgs.length++] = node;
      callback.apply(this, cbArgs);
    });
  };
}

function forgeMembership (type, node) {
  node.ucg.peering.get(proxy(function (peering) {
    node.hdc.amendments.current(function (err, am) {
      var number = 0;
      if(am){
        number = am.number + 1;
      }
      var ms = new hdc.Membership();
      ms.version = "1";
      ms.currency = peering.currency;
      ms.basis = number;
      ms.status = type;
      console.log(ms.getRaw());
    });
  }));
}

function proxy(callback){
  return function (err, res) {
    if(err){
      if(err.code)
        console.error("Error: " + err.code);
      else
        console.error("Error: " + err);
      process.exit(1);
      return;
    }
    else callback(res);
  }
}

function splitCoins (arg) {
  var strings = arg.split(',');
  var values = [];
  for(var i = 0; i < strings.length - 1; i = i + 2){
    values.push({
      base: parseInt(strings[i], 10),
      power: parseInt(strings[i+1], 10)
    });
  }
  return values;
}

function splitCoins2 (arg) {
  var strings = arg.split(',');
  var values = [];
  for(var i = 0; i < strings.length; i++){
    var group = strings[i].split(':');
    var start = strings[0].match(/^[A-Z\d]{40}/) ? 1 : 0;
    for(var j = start; j < group.length; j++){
      if(group[j] && group[j] != ''){
        values.push({
          issuer: start == 1 ? group[0] : '',
          number: group[j]
        });
      }
    }
  }
  return values;
}

String.prototype.trim = function(){
  return this.replace(/^\s+|\s+$/g, '');
};

String.prototype.unix2dos = function(){
  return this.dos2unix().replace(/\n/g, '\r\n');
};

String.prototype.dos2unix = function(){
  return this.replace(/\r\n/g, '\n');
};
