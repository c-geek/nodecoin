#!/usr/bin/env node
var request = require('request');
var program = require('commander');
var vucoin  = require('../index');
var hdc     = require('hdc');
var fs      = require('fs');

// Default values
program.host = "localhost";
program.port = "8081";

program
  .version('0.1.0')
  .option('--key <keyFile>', 'File of the key to submit.')
  .option('--search <search>', 'Search string')
  .option('--membership <request>', 'Signed membership request file to send.')
  .option('--votefile <voteFile>', 'Vote file to send.')
  .option('-s, --signature <sigFile>', 'File of a signature to append.')
  .option('-h, --host <address>', 'DNS, IPv4 or IPv6 address of the node to contact.')
  .option('-p, --port <port>', 'Port of the node to contact.')

program
  .command('pks-add')
  .description('Add signed public keys')
  .action(connect(function (node) {
    if(!program.key){
      console.error("Requires --add parameter");
      return;
    }
    var key = fs.readFileSync(program.key, 'utf8');
    var sign = null;
    if(~key.indexOf('-----BEGIN PGP SIGNATURE-----')){
      sign = key.substr(key.indexOf('-----BEGIN PGP SIGNATURE-----'));
      key = key.substr(0, key.indexOf('-----BEGIN PGP SIGNATURE-----'));
    }
    else if(program.signature){
      signature = fs.readFileSync(signature, 'utf8');
    }
    if(key && sign){
      node.pks.add(key, sign, proxy(function (res) {
        var name = res.name || '';
        var comment = res.comment ? ' (' + res.comment + ')' : '';
        var email = res.email ? ' <' + res.email + '>' : '';
        console.log("Posted key '" + res.fingerprint + "' of " + name + comment + email);
      }));
    }
    else{
      if(!key){
        console.error("Missing key in given file.");
      }
      if(!sign){
        console.error("Missing signature in given file.");
      }
    }
    return;
  }));

program
  .command('pks-lookup')
  .description('Search for public keys.')
  .action(connect(function (node) {
    if(!program.search){
      console.error("Requires --search parameter");
      return;
    }
    node.pks.lookup(program.search, proxy(function (res) {
      var keys = res.keys;
      console.log("Lookup '" + program.search + "' keys:");
      for (var i = 0; i < keys.length; i++) {
        console.log(keys[i].fingerprint);
      };
    }));
    return;
  }));

program
  .command('peer')
  .description('Show remote peering informations.')
  .action(connect(function (node) {
    node.ucg.peering(proxy(function (res) {
      console.log("Currency: ", res.currency);
      console.log("Public key FPR: ", res.key);
      console.log("Remote host: ", res.remote.host);
      console.log("Remote port: ", res.remote.port);
      console.log("Peers number: ", res.peers.length);
      console.log("Peers list: ");
      res.peers.forEach(function (peer) {
        console.log(JSON.stringify(peer));
      });
    }));
    return;
  }));

program
  .command('am-current')
  .description('View current top amendment of the contract.')
  .action(connect(function (node) {
    node.hdc.amendments.current(proxy(function (res) {
      var amendment = new hdc.Amendment(res.raw);
      console.log(amendment.getRaw());
    }));
    return;
  }));

program
  .command('am-contract')
  .description('View all amendments of the contract.')
  .action(connect(function (node) {
    function getAmendment (number, hash) {
      node.hdc.amendments.view.self(number, hash, proxy(function (res) {
        var amendment = new hdc.Amendment(res.raw);
        console.log(res.raw);
        if(amendment.previousHash){
          getAmendment(amendment.number - 1, amendment.previousHash);
        }
      }));
    }
    node.hdc.amendments.current(proxy(function (res) {
      var amendment = new hdc.Amendment(res.raw);
      console.log(amendment.getRaw());
      if(amendment.previousHash){
        getAmendment(amendment.number - 1, amendment.previousHash);
      }
    }));
    return;
  }));

program
  .command('join')
  .description('Send join membership request.')
  .action(connect(function (node) {
    if(!program.membership){
      console.error("Requires --membership parameter");
      return;
    }
    node.hdc.community.join(program.membership, proxy(function (res) {
      console.log("Posted membership request '" + res.request.status + "' of Amendment #" + res.request.basis);
    }));
    return;
  }));

program
  .command('vote')
  .description('Send vote request.')
  .action(connect(function (node) {
    if(!program.votefile){
      console.error("Requires --votefile parameter");
      return;
    }
    var vote = fs.readFileSync(program.votefile, 'utf8');
    node.hdc.amendments.votes.post(vote, proxy(function (res) {
      console.log("Posted vote for Amendment #" + res.amendment.number);
    }));
    return;
  }));

program
  .command('forge-join')
  .description('Forge HDC membership JOIN request.')
  .action(connect(function (node) {
    forgeMembership('JOIN', node);
    return;
  }));

program
  .command('forge-actu')
  .description('Forge HDC membership ACTUALIZE request.')
  .action(connect(function (node) {
    forgeMembership('ACTUALIZE', node);
    return;
  }));

program
  .command('forge-leave')
  .description('Forge HDC membership LEAVE request.')
  .action(connect(function (node) {
    forgeMembership('LEAVE', node);
    return;
  }));

program.parse(process.argv);

function connect(callback) {
  return function () {
    var cbArgs = arguments;
    vucoin(program.host, program.port, function (err, node) {
      if(err){
        console.error(err);
        return;
      }
      cbArgs.length--;
      cbArgs[cbArgs.length++] = node;
      callback.apply(this, cbArgs);
    });
  };
}

function forgeMembership (type, node) {
  node.ucg.peering(proxy(function (peering) {
    node.hdc.amendments.current(proxy(function (am) {
      var amendment = new hdc.Amendment(am.raw);
      var ms = new hdc.Membership();
      ms.version = "1";
      ms.currency = peering.currency;
      ms.basis = am.number;
      ms.status = type;
      console.log(ms.getRaw());
    }));
  }));
}

function proxy(callback){
  return function (err, res) {
    if(err){
      if(err.code)
        console.error("Error: " + err.code);
      else
        console.error("Error: " + err);
      process.exit(1);
      return;
    }
    else callback(res);
  }
}
